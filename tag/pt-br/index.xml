<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pt-br | Felipe Sodré M. Barros</title>
    <link>/tag/pt-br/</link>
      <atom:link href="/tag/pt-br/index.xml" rel="self" type="application/rss+xml" />
    <description>pt-br</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Fri, 15 Jul 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_huf522d53bb96c01347942c9c8d4a9566b_18603_512x512_fill_lanczos_center_2.png</url>
      <title>pt-br</title>
      <link>/tag/pt-br/</link>
    </image>
    
    <item>
      <title>Aprendendo sobre `datetime`, SQLAlchemy e PostgreSQL a partir de bugs</title>
      <link>/post/aprendendo-sobre-datetime-sqlalchemy-e-postgresql-a-partir-de-bugs/</link>
      <pubDate>Fri, 15 Jul 2022 00:00:00 +0000</pubDate>
      <guid>/post/aprendendo-sobre-datetime-sqlalchemy-e-postgresql-a-partir-de-bugs/</guid>
      <description>&lt;p&gt;Há algum tempo comecei a perceber um &amp;ldquo;comportamento estranho&amp;rdquo; (ainda que tenha colocado o termo bug no título, acho que não é o caso. Foi para atrir mais atenção, mesmo:) relacionado aos dados de data e hora num sistema que estava desenvolvendo. Minha reação inicial, praticamente um instinto de sobrevivência, foi simplesmente resolver a situação contornando o problema. Mas chegou um momento que precisei entender a origem do mesmo. Mais uma vez tive que fazer um exercício de seguir/isolar o problema que me assombrava (&lt;a href=&#34;felipesbarros.github.io&#34;&gt;veja outros artigos que produzi sobre bugs/comportamentos estranhos&lt;/a&gt;) para tentar compreender o motivo da sua existência. Esse processo tomou-me alguns dias e, claro, proporcionou alguns aprendizados.&lt;/p&gt;
&lt;p&gt;Ainda que agora, tendo resolvido e entendido as causas e origens desse comportamento, tudo parece óbvio, decidi compartilhar um pouco deste processo, pois nessa busca por soluções não encontrei nada que me ajudasse de forma objetiva.&lt;/p&gt;
&lt;p&gt;Criei um ambiente para reproduzir esses &amp;ldquo;comportamentos estranhos&amp;rdquo; (&lt;a href=&#34;#Preparando-ambiente-de-desenvolvimento&#34;&gt;há uma seção sobre como preparar um ambiente para poder reproduzir esses códigos&lt;/a&gt;) e deixarei os trechos de códigos usados para vocês poderem reproduzir os passos dados. Irei trabalhar em todos os exemplos com um mesmo objeto de data e hora (instância &lt;code&gt;datetime&lt;/code&gt;) mudando apenas o uso de fuso horário, para torná-los conscientes (&lt;em&gt;aware&lt;/em&gt;) ou não (&lt;em&gt;naive&lt;/em&gt;, ingênuo) (leia um pouco sobre isso &lt;a href=&#34;https://docs.python.org/3/library/datetime.html#aware-and-naive-objects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aqui&lt;/a&gt;). Na seção final, &amp;ldquo;resumo&amp;rdquo;, deixo os principais aprendizados deste processo.&lt;/p&gt;
&lt;h2 id=&#34;contextualizando-o-sistema&#34;&gt;Contextualizando o sistema&lt;/h2&gt;
&lt;p&gt;Antes de tudo, lhes resumo a parte que importa do sistema:&lt;/p&gt;
&lt;p&gt;O mesmo estava em um servidor com fuso horário UTC, e nele eu manipulava um dado de data e hora, usando o módulo python &lt;a href=&#34;https://docs.python.org/3/library/datetime.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, com &lt;em&gt;time zone&lt;/em&gt; consciente (&lt;code&gt;aware&lt;/code&gt;), transformando-os ao &lt;em&gt;time zone&lt;/em&gt; de Brasília (-0300). Esse dado era, então, persistido no banco de dados &lt;a href=&#34;https://www.postgresql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PostgreSQL&lt;/a&gt;, que estava em outro servidor, também com fuso horário UTC. Os dados eram persistidos em duas colunas diferentes: uma coluna &lt;a href=&#34;https://www.PostgreSQL.org/docs/current/datatype-datetime.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DateTime com &lt;em&gt;time zone&lt;/em&gt; consciente&lt;/a&gt; e numa coluna de texto onde, além da data e hora em formato &lt;a href=&#34;https://docs.python.org/3/library/datetime.html#datetime.date.isoformat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iso&lt;/a&gt;, uma observação textual era adicionada (que não vem ao caso, agora). Mas é importante saber que tínhamos o mesmo dado de data e hora persistido como tal e como texto.&lt;/p&gt;
&lt;p&gt;Um detalhe não menos importante é o fato de eu estar usando o módulo &lt;a href=&#34;https://pythonhosted.org/pytz/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;pytz&lt;/code&gt;&lt;/a&gt; para definir o fuso &lt;code&gt;America/Sao_Paulo&lt;/code&gt;, e o &lt;a href=&#34;https://www.sqlalchemy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SQLAlchemy&lt;/a&gt;, para fazer a conexão com o banco de dados, commit e etc. Pensando em facilitar a minha vida, estive usando o &lt;a href=&#34;https://dbeaver.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DBeaver&lt;/a&gt;, uma interface gráfica para gestão de banco de dados. Ou seja, usava o DBeaver para conectar ao banco de dados e observar o que estava sendo persistido sem precisar fazê-lo pelo &lt;a href=&#34;https://www.postgresql.org/docs/current/app-psql.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;psql&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;reproduzindo-comportamentos-estranhos&#34;&gt;Reproduzindo comportamentos estranhos&lt;/h2&gt;
&lt;p&gt;Basicamente criei uma instância &lt;code&gt;datetime&lt;/code&gt; ingênua (&lt;em&gt;naive&lt;/em&gt;) em relação ao &lt;em&gt;time zone&lt;/em&gt; e outra com &lt;em&gt;time zone&lt;/em&gt; declarado ( consciente, &lt;em&gt;aware&lt;/em&gt;). Criei uma instância da tabela persistindo cada dado nas suas respectivas colunas (consciente na coluna consciente e ingênuo na coluna ingênua) (&lt;a href=&#34;#Preparando-ambiente-de-desenvolvimento&#34;&gt;veja aqui sobre a criação do ambiente para reproduzir esses códigos&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pytz
from datetime import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine(
        f&amp;quot;postgresql+psycopg2://postgres:password@localhost:5432/postgres&amp;quot;)

Session = sessionmaker(bind=engine)
session = Session()


BR_TIME_ZONE = pytz.timezone(&amp;quot;America/Sao_Paulo&amp;quot;)

naive = datetime(2022, 5, 27, 12, 30, 0, 0)
aware = naive.replace(tzinfo=BR_TIME_ZONE)

record = DateTimeTable(
    date_time_tz_aware=aware,
    isoformat_tz_aware=f&amp;quot;{aware.isoformat()}&amp;quot;,
    date_time_naive=naive,
    isoformat_naive=f&amp;quot;{naive.isoformat()}&amp;quot;
)

session.add(record)
session.commit()
session.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao fazer o commit e consultar a base de dados, começa o terror e pânico:&lt;/p&gt;
&lt;p&gt;Usando o DBeaver para acessar o registro criado (seja pela interface gráfica como pela query da GUI), observei que:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O valor persistido na coluna consciente foi alterado em seis minutos (acrescidos). &lt;strong&gt;Deveria ser 12:30 e passou a ser 12:36&lt;/strong&gt;, ao passo que a informação de &lt;em&gt;time zone&lt;/em&gt; é apresentada de forma correta: &lt;code&gt;-0300&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;O dado da coluna &lt;code&gt;iso_format_tz_aware&lt;/code&gt; possui a informação sem qualquer alteração. Ao passo que a &lt;em&gt;time zone&lt;/em&gt; informada não é a esperada (&lt;code&gt;-0300&lt;/code&gt;), mas &lt;code&gt;-03:06&lt;/code&gt;. Lembrem-se que o &lt;em&gt;time zone&lt;/em&gt; da coluna &lt;code&gt;date_time_aware&lt;/code&gt; é informado apenas &lt;code&gt;-0300&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Os dados persistidos nos campos &lt;em&gt;time zone&lt;/em&gt; ingênuos não apresentaram qualquer alteração.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2022-05-27 12:36:00.000 -0300&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:06&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Contudo, ao acessar esses dados usando o SQLAlchemy, a confusão aumenta:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2022-05-27 15:36:00+00:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:06&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Reparem que agora temos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Na coluna &lt;code&gt;date_time_tz_aware&lt;/code&gt;, o objeto tem três horas e seis minutos acrescidos e o &lt;em&gt;time zone&lt;/em&gt; informado como UTC (&lt;code&gt;+00:00&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Os dados das colunas &lt;code&gt;iso_format&lt;/code&gt;, &lt;code&gt;date_time_naive&lt;/code&gt; e &lt;code&gt;isoformat_naive&lt;/code&gt; apresentam os dados assim como estão no banco de dados.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Comportamentos estranhos a serem resolvidos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O &lt;em&gt;time zone&lt;/em&gt; deveria ser de &lt;code&gt;-0300&lt;/code&gt;. &lt;strong&gt;De onde veio os seis minutos a mais?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Afinal, o dado é persistido no banco de dados em UTC (como retornado pelo SQLAlchemy) ou no fuso horário informado no objeto &lt;em&gt;datetime&lt;/em&gt; (como retornado pelo DBeaver)?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;resolvendo-problema-de-definição-de-time-zone&#34;&gt;Resolvendo problema de definição de &lt;em&gt;time zone&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Ao apresentar esses problemas aos amigos que tenho como referência na área, um deles, o &lt;a href=&#34;https://twitter.com/georgersilva&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@georgersilva&lt;/a&gt;, me alertou que a forma como eu estava definido o &lt;em&gt;time zone&lt;/em&gt; estava equivocado. A única direção dada por ele foi &lt;a href=&#34;https://stackoverflow.com/questions/1379740/pytz-localize-vs-datetime-replace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;essa pergunta no Stack Overflow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Um comentário me chamou a atenção:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@MichaelWaterfall: pytz.timezone() may correspond to several tzinfo objects (same place, different UTC offsets, &lt;em&gt;time zone&lt;/em&gt; abbreviations). tz.localize(d) tries to find the correct tzinfo for the given d local time (some local time is ambiguous or doesn&amp;rsquo;t exist). replace() just sets whatever (random) info pytz &lt;em&gt;time zone&lt;/em&gt; provides by default without regard for the given date (LMT in recent versions). tz.normalize() may adjust the time if d is a non-existent local time e.g., the time during DST transition in Spring (northern hemisphere) otherwise it does nothing in this case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Em tradução livre:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pytz.timezone() pode corresponder a objetos com diferentes tzinfo (mesmo local, diferentes &lt;em&gt;offset&lt;/em&gt; em relação ao UTC). tz.localize(d) tenta encontrar o tzinfo correto para um dada hora local (algumas horas locais são ambíguas ou inexistentes). replace() apenas define qualquer informação de &lt;em&gt;time zone&lt;/em&gt; por padrão sem se preocupar com a data. tz.normalize() deve ajustar a informação de tempo se o objeto d não possuir informação de hora local.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Como estou usando o &lt;code&gt;pytz&lt;/code&gt; para definir um objeto de data com fuso horário, o &lt;a href=&#34;https://docs.python.org/3/library/datetime.html#datetime.datetime.replace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt; não seria a forma correta, mas sim, o método &lt;a href=&#34;http://pytz.sourceforge.net/index.html?highlight=localize&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;localize&lt;/code&gt;&lt;/a&gt; da própria instância &lt;code&gt;pytz.timezone&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vamos testar, então:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BR_TIME_ZONE = pytz.timezone(&amp;quot;America/Sao_Paulo&amp;quot;)
naive = datetime(2022, 5, 27, 12, 30, 0, 0)
naive.replace(tzinfo=BR_TIME_ZONE)
# datetime.datetime(2022, 5, 27, 12, 30, tzinfo=&amp;lt;DstTzInfo &#39;America/Sao_Paulo&#39; LMT-1 day, 20:54:00 STD&amp;gt;)
BR_TIME_ZONE.localize(naive)
# datetime.datetime(2022, 5, 27, 12, 30, tzinfo=&amp;lt;DstTzInfo &#39;America/Sao_Paulo&#39; -03-1 day, 21:00:00 STD&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reparem a diferença que isso fez no parâmetro &lt;code&gt;tzinfo&lt;/code&gt; da instância: há uma diferença de seis minutos no objeto ao qual usei o método &lt;code&gt;replace()&lt;/code&gt;. Ao usar o &lt;code&gt;localize()&lt;/code&gt;, a informação de fuso horário &amp;ldquo;-03&amp;rdquo; aparece.&lt;/p&gt;
&lt;p&gt;Fiz mais um teste para entender se o problema é o método &lt;code&gt;replace&lt;/code&gt; ou a forma como o &lt;code&gt;pytz&lt;/code&gt; define o &lt;em&gt;time zone&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;datetime(2022, 5, 27, 12, 30, 0, 0, tzinfo=BR_TIME_ZONE)
# datetime.datetime(2022, 5, 27, 12, 30, tzinfo=&amp;lt;DstTzInfo &#39;America/Sao_Paulo&#39; LMT-1 day, 20:54:00 STD&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mesmo passando o &lt;em&gt;time zone&lt;/em&gt; do &lt;code&gt;pytz&lt;/code&gt; como parâmetro &lt;code&gt;tzinfo&lt;/code&gt;, a diferença de seis minutos segue (20:54). Ou seja, também não seria a forma correta.&lt;/p&gt;
&lt;p&gt;Na documentação do &lt;code&gt;localize&lt;/code&gt;, há apenas a menção:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unfortunately using the tzinfo argument of the standard datetime constructors ‘’does not work’’ with pytz for many timezones.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ao salvar no banco de dados o objeto &lt;code&gt;aware&lt;/code&gt; criado usando o &lt;code&gt;localize&lt;/code&gt;, os dados foram, enfim, salvos de forma correta:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2022-05-27 12:30:00.000 -0300&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;✔️ OK, um problema resolvido. Gracias, &lt;a href=&#34;https://twitter.com/georgersilva&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@georgersilva&lt;/a&gt;!&lt;br&gt;
❓ Mas ainda fica o mistério das conversões entre o dado acessado pelo DBeaver daquele acessado pelo SQLAlchemy.&lt;/p&gt;
&lt;p&gt;Enquanto estava tentando resolver esse segundo problema, o &lt;a href=&#34;https://twitter.com/dunossauro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@dunossauro&lt;/a&gt; fez uma &lt;a href=&#34;https://youtu.be/BImF-dZYass?t=3948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; live de python sobre &lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;. Fui assistir e vi que ele indicou usarmos a definição de &lt;em&gt;time zone&lt;/em&gt; usando &lt;a href=&#34;https://docs.python.org/3/library/datetime.html#timedelta-objects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt;. Me pareceu sensato.&lt;/p&gt;
&lt;p&gt;Vamos testar, então:&lt;/p&gt;
&lt;h3 id=&#34;resolvendo-problema-de-definição-de-time-zone-com-timedelta&#34;&gt;Resolvendo problema de definição de &lt;em&gt;time zone&lt;/em&gt; com &lt;code&gt;timedelta&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import timezone, timedelta

# BR_TIME_ZONE = pytz.timezone(&amp;quot;America/Sao_Paulo&amp;quot;)
BR_TIME_ZONE = timezone(timedelta(hours=-3))
datetime(2022, 5, 27, 12, 30, 0, 0, tzinfo=BR_TIME_ZONE)
# datetime.datetime(2022, 5, 27, 12, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=75600)))
datetime(2022, 5, 27, 12, 30, 0, 0).replace(tzinfo=BR_TIME_ZONE)
# datetime.datetime(2022, 5, 27, 12, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=75600)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reparem que agora não estamos mais usando uma instância &lt;a href=&#34;http://pytz.sourceforge.net/#tzinfo-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; do &lt;code&gt;pytz&lt;/code&gt; e por isso não podemos usar o método &lt;code&gt;localize()&lt;/code&gt;. Com o timedelta, obtivemos os resultados esperados tanto passando o objeto no parâmetro &lt;code&gt;tzinfo&lt;/code&gt;, na criação da instância &lt;code&gt;datetime&lt;/code&gt;, como ao usar o método &lt;code&gt;replace&lt;/code&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000 -0300&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Dessa forma também temos os dados persistidos corretamente e ainda nos poupa de usar o &lt;code&gt;pytz&lt;/code&gt;. Gracias, &lt;a href=&#34;https://twitter.com/dunossauro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@dunossauro&lt;/a&gt;!&lt;/p&gt;
&lt;h3 id=&#34;o-mistério-das-consultas-sendo-retornadas-em-utc-e--0300&#34;&gt;O mistério das consultas sendo retornadas em UTC e &lt;code&gt;-0300&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Só para refrescar a memória: Ao acessar os dados persistidos no banco de dados usando o DBeaver, os recebia com o &lt;em&gt;time zone&lt;/em&gt; -0300, enquanto ao acessar pelo SQLAlchemy, os mesmos dados eram retornados em UTC +00:00.&lt;/p&gt;
&lt;p&gt;Decidi acessar o banco e fazer as consultas apresentadas anteriormente pelo &lt;a href=&#34;https://www.PostgreSQLql.org/docs/current/app-psql.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;psql&lt;/a&gt; e pelo DBeaver para confirmar:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;o fuso horário da instância do banco de dados, e;&lt;/li&gt;
&lt;li&gt;o fuso horário dos dados persistidos;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;confirmando-o-fuso-horário-da-instância-do-banco-de-dados&#34;&gt;Confirmando o fuso horário da instância do banco de dados&lt;/h4&gt;
&lt;p&gt;Executando o mesmo comando no &lt;code&gt;psql&lt;/code&gt; e DBeaver para uma mesma instância de banco dados tive diferentes retornos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commandline&#34;&gt;psql -h localhost -U postgres -p 5432 postgres

show timezone;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;img/show_timezone_psql.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/show_timezone_dbeaver.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Eis, então, que fica evidente: A ferramenta usada para conexão e consulta ao banco de dados é que foram as responsáveis pelas diferenas observadas no &lt;em&gt;time zone&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Isso me fez lembrar da documentação do PostgreSQL que já havia lido, mas não tinha dado a devida atenção:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For timestamp with time zone, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT). An input value that has an explicit time zone specified is converted to UTC using the appropriate offset for that time zone. If no time zone is stated in the input string, then it is assumed to be in the time zone indicated by the system&amp;rsquo;s &lt;em&gt;time zone&lt;/em&gt; parameter, and is converted to UTC using the offset for the &lt;em&gt;time zone&lt;/em&gt; zone.
&lt;a href=&#34;https://www.postgresql.org/docs/current/datatype-datetime.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fonte&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Em tradução livre:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para dados com informação de &lt;em&gt;time zone&lt;/em&gt;, o valor armazenado estará sempre em UTC (também conhecido como GMT). Um valor de entrada que não tenha &lt;em&gt;time zone&lt;/em&gt; declarado explicitamente será convertido a UTC usando o &lt;em&gt;time zone&lt;/em&gt; indicado pelo sistema.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A partir disso, várias constatações:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Os dados que possuem a informação de &lt;em&gt;time zone&lt;/em&gt;, são convertidos a UTC. Os dados sem essa definição é entendido como já estando em UTC, logo não é convertido.&lt;/li&gt;
&lt;li&gt;O DBeaver identificou o &lt;em&gt;time zone&lt;/em&gt; da minha máquina e ao retornar uma consulta já convertia todos os dados considerando o &lt;em&gt;time zone&lt;/em&gt; da minha maquina.&lt;/li&gt;
&lt;li&gt;Não é o SQLAlchemy que define como os dados serão resgatados, mas o PostgreSQL. Na verdade, essa definição é feita pela seção de conexão com o banco de dados.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vejam:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;psql -h localhost -U postgres -p 5432 postgres

PostgreSQL= show time zone;
#  time zone
# ----------
#  Etc/UTC
# (1 row)

select * from datetime;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com uma seção (conexão) recém iniciada, o &lt;em&gt;time zone&lt;/em&gt; é configurado para UTC (padrão), com os dados sendo retornados em UTC.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;isoformat_tz_aware&lt;/th&gt;
&lt;th&gt;datetime_naive&lt;/th&gt;
&lt;th&gt;isoformat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2022-05-27 15:36:00+00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:06&lt;/td&gt;
&lt;td&gt;2022-05-27 15:36:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:06&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00+00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Se, na mesma conexão, eu configuro o &lt;em&gt;time zone&lt;/em&gt; para &lt;code&gt;America/Sao_Paulo&lt;/code&gt;, e executo a mesma query, os dados na coluna com &lt;em&gt;time zone&lt;/em&gt; consciente serão apresentados convertidos ao &lt;em&gt;time zone&lt;/em&gt; definido na conexão (&lt;code&gt;-0300&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;postgres=set timezone = &#39;America/Sao_Paulo&#39;;
#SET
postgres=show timezone;
#      timezone      
# -------------------
#  America/Sao_Paulo
# (1 row)


select * from datetime;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eis que todos os dados são retornados em &lt;code&gt;-0300&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;isoformat_tz_aware&lt;/th&gt;
&lt;th&gt;datetime_naive&lt;/th&gt;
&lt;th&gt;isoformat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2022-05-27 12:36:00-03&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:06&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 09:30:00-03&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Tudo parece bem óbvio, não? Mas uma coisa que foi fundamental para a minha confusão mental sobre esse comportamento: o fato de estar usando o DBeaver os dados eram apresentados já convertidos para a &lt;em&gt;time zone&lt;/em&gt; do meu sistema e, com isso, eu acreditava que os mesmos estavam sendo persistidos como tal no banco de dados. Ao acessar os dados pelo SQLAlchemy (que usa uma seção padrão, sem configuração de &lt;em&gt;time zone&lt;/em&gt;, logo em UTC) recebia os dados em UTC. Ficando sem entender o que, de fato, estava sendo persistido.&lt;/p&gt;
&lt;p&gt;:heavy_checkmark: Fica o aprendizado: O PostgreSQL irá retornar os dados de data e hora no &lt;em&gt;time zone&lt;/em&gt; da seção de conexão, que por padrão é UTC. Caso vc queira receber-los em outro &lt;em&gt;time zone&lt;/em&gt;, basta definir usando o &lt;a href=&#34;https://www.postgresql.org/docs/current/sql-set.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;SET timezone&lt;/code&gt;&lt;/a&gt;, ou, se for usando o SQLAlchemy, você poderá fazê-lo usando o parâmetro &lt;a href=&#34;https://docs.sqlalchemy.org/en/14/core/engines.html#sqlalchemy.create_engine.params.connect_args&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;connect_args&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;engine = create_engine(..., connect_args={&amp;quot;options&amp;quot;: &amp;quot;-c timezone=-3&amp;quot;})`
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;coluna-naive-e-aware&#34;&gt;coluna naive e aware&lt;/h3&gt;
&lt;p&gt;Ainda que tenha tomado um tempo considerável resolução de todas essas dúvidas, não chegou a esgotar a minha paciência. Por isso, fiz mais alguns testes, para tentar entender, de vez, a diferença entre usar ou não coluna com &lt;em&gt;time zone&lt;/em&gt; consciente e ingênua no PostgreSQL.&lt;/p&gt;
&lt;p&gt;Ainda que já esteja superada a dúvida sobre as diferenças entre DBeaver e SQLAlchemy, seguirei apresentando as consultas usando ambas ferramentas, pois isso nos ajudará a entender as consequências ao usar campo consciente ou ingênuo.&lt;/p&gt;
&lt;h4 id=&#34;primeiro-teste&#34;&gt;Primeiro teste:&lt;/h4&gt;
&lt;p&gt;Inseri em ambos campos de &lt;code&gt;datetime&lt;/code&gt; (consciente e ingênuo), um objeto com &lt;em&gt;time zone&lt;/em&gt; consciente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;record = DateTimeTable(
    date_time_tz_aware=aware,
    isoformat_tz_aware=f&amp;quot;{aware.isoformat()}&amp;quot;,
    date_time_naive=aware,
    isoformat_naive=f&amp;quot;{aware.isoformat()}&amp;quot;
)
session.add(record)
session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao fazê-lo, o PosgreSQL entenderá o &lt;em&gt;time zone&lt;/em&gt; do dado e, como dito anteriormente, os persitirá em UTC (logo, acrescentando três horas). &lt;strong&gt;Isso tanto para o campo consciente como para o campo ingênuo&lt;/strong&gt;. A diferença, contudo estará no resgate da informação por uma seção em UTC ou em outro &lt;em&gt;time zone&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;Acessando esse dado pelo DBeaver (seção com &lt;em&gt;time zone&lt;/em&gt; configurado em -0300), tenho o valor do campo &lt;code&gt;aware&lt;/code&gt; convertido ao &lt;em&gt;time zone&lt;/em&gt; da seção (-0300) e indicando o mesmo, ao passo que o valor persistido no campo &lt;code&gt;naive&lt;/code&gt; se mantêm em formato UTC &lt;strong&gt;e sem a indicação do &lt;em&gt;time zone&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000 -0300&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;td&gt;2022-05-27 15:30:00.000&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Já pelo SQLAlchemy a informação persistida no campo &lt;em&gt;time zone&lt;/em&gt; consciente é retornada respeitando o &lt;em&gt;time zone&lt;/em&gt; da seção (logo, &lt;em&gt;time zone&lt;/em&gt; UTC) e no campo ingênuo, não há alteração.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 15:30:00+00:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;td&gt;2022-05-27 15:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00-03:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;segundo-teste&#34;&gt;Segundo teste:&lt;/h4&gt;
&lt;p&gt;Ao inserir em ambos campos, um objeto ingênuo, o PostgreSQL entende que os mesmos já estão em UTC. Logo, ao acessá-los pelo DBeaver (seção com &lt;em&gt;time zone&lt;/em&gt; -0300), o valor no campo consciente apresenta o desconto de três horas e apresenta a informação de &lt;em&gt;time zone&lt;/em&gt; -0300, e na coluna &lt;code&gt;naive&lt;/code&gt;, os valores não são alterados.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# terceiro registro inserindo datetime naive sempre
record = DateTimeTable(
    date_time_tz_aware=naive,
    isoformat_tz_aware=f&amp;quot;{naive.isoformat()}&amp;quot;,
    date_time_naive=naive,
    isoformat_naive=f&amp;quot;{naive.isoformat()}&amp;quot;
)
session.add(record)
session.commit()

session.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 09:30:00.000 -0300&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00.000&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Acessando so dados pelo SQLAlchemy, tanto a coluna consciente como a ingênua apresentam o mesmo valor. Contudo, no campo consciente, a informação do &lt;em&gt;time zone&lt;/em&gt; é existente (+00:00:00).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;date_time_tz_aware&lt;/th&gt;
&lt;th&gt;iso_format_tz_aware&lt;/th&gt;
&lt;th&gt;date_time_naive&lt;/th&gt;
&lt;th&gt;isofomat_naive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00+00:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27 12:30:00&lt;/td&gt;
&lt;td&gt;2022-05-27T12:30:00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;preparando-ambiente-de-desenvolvimento&#34;&gt;Preparando ambiente de desenvolvimento&lt;/h2&gt;
&lt;p&gt;Para isolar e reproduzir os comportamentos apresentados segui os seguintes passos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criação de um ambiente virtual;&lt;/li&gt;
&lt;li&gt;Activação do ambiente virtual;&lt;/li&gt;
&lt;li&gt;Atualização do pip;&lt;/li&gt;
&lt;li&gt;INstalação dos pacotes listados em &lt;a href=&#34;requirements.txt&#34;&gt;&lt;code&gt;requirements.txt&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Criei uma instância do banco de dados &lt;a href=&#34;#Docker-com-PostgreSQL&#34;&gt;PostgreSQL usando docker&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Criei os &lt;a href=&#34;#Modelo-de-dados-e-conex%c3%a3o-com-SQLAlchemy&#34;&gt;modelos as tabelas usando SQLAlchemy&lt;/a&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mkdir datetime
cd datetime
python -m venv .venv
source .venv/bin/activate
pip intall --upgrade pip
pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-com-postgresql&#34;&gt;Docker com PostgreSQL&lt;/h3&gt;
&lt;p&gt;Para facilitar, criei uma instância Docker com a imagem original do PostgreSQLQL. Caso já o tenha instalado em sua máquina, desconsidere.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commandline&#34;&gt;docker pull PostgreSQL

docker run --name teste_datetime -e PostgreSQL_PASSWORD=password -d PostgreSQL

# confirmando existencia
docker container ps
#CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                    NAMES
#c77150c506a8   PostgreSQL   &amp;quot;docker-entrypoint.s…&amp;quot;   6 seconds ago   Up 5 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;modelo-de-dados-e-conexão-com-sqlalchemy&#34;&gt;Modelo de dados e conexão com SQLAlchemy&lt;/h3&gt;
&lt;p&gt;Crio, em um arquivo &lt;code&gt;models.py&lt;/code&gt;, a classe que representará a tabela &lt;code&gt;datetime&lt;/code&gt; do banco de dados. Nela teremos os campos &lt;code&gt;date_time_tz_aware&lt;/code&gt;, &lt;code&gt;date_time_aive&lt;/code&gt; que são, ambos, &lt;a href=&#34;https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.DateTime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;DateTime()&lt;/code&gt;&lt;/a&gt;, com o parâmetro &lt;a href=&#34;https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.DateTime.params.timezone&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;*time zone*=True&lt;/code&gt;&lt;/a&gt; &lt;strong&gt;verdadeiro&lt;/strong&gt; e &lt;strong&gt;falso&lt;/strong&gt;, respectivamente. Os campos &lt;code&gt;isoformat_tz_aware&lt;/code&gt; e &lt;code&gt;isoformat_naive&lt;/code&gt; serão os campos textuais que persistirão os dados de data e hora em formato &lt;a href=&#34;https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;isoformat()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# models.py
import json

from sqlalchemy import Integer, DateTime, Text
from sqlalchemy import create_engine, Column
from sqlalchemy.ext.declarative import declarative_base


Base = declarative_base()


BD_USERNAME = &amp;quot;PostgreSQL&amp;quot;
BD_PASSWORD = &amp;quot;password&amp;quot;
BD_HOST = &amp;quot;localhost&amp;quot;
BD_PORT = &amp;quot;5433&amp;quot;
BD_NAME = &amp;quot;PostgreSQL&amp;quot;


def db_connect():
    return create_engine(
        f&amp;quot;PostgreSQLql+psycopg2://{BD_USERNAME}:{BD_PASSWORD}@{BD_HOST}:{BD_PORT}/{BD_NAME}&amp;quot;
    )


def create_table(engine):
    Base.metadata.create_all(engine)


class DateTimeTable(Base):
    __tablename__ = &amp;quot;datetime&amp;quot;

    id = Column(Integer, primary_key=True)
    date_time_tz_aware = Column(DateTime(timezone=True))
    isoformat_tz_aware = Column(Text)
    date_time_naive = Column(&amp;quot;datetime_naive&amp;quot;, DateTime(timezone=False))
    isoformat_naive = Column(Text)


engine = db_connect()
create_table(engine)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;identificando-time-zone-das-instâncias-de-trabalho&#34;&gt;Identificando &lt;em&gt;time zone&lt;/em&gt; das instâncias de trabalho&lt;/h3&gt;
&lt;p&gt;Para confirmar que estamos reproduzindo as mesmas situações, vamos confirmar o &lt;em&gt;time zone&lt;/em&gt; da base de dados.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker PostgreSQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commandline&#34;&gt;psql -h localhost -U PostgreSQL -p 5433
show timezone;
# timezone 
#----------
# Etc/UTC
#(1 row)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao executar a consulta &lt;code&gt;select now()&lt;/code&gt;, ele me dá a data e hora com a info de &lt;em&gt;time zone&lt;/em&gt; utc (+00):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-commandline&#34;&gt;select now();
#              now              
#-------------------------------
# 2022-05-27 15:36:59.903336+00
#(1 row)


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E o mesmo com python:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;python&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime
datetime.now().astimezone().tzinfo
#datetime.timezone(datetime.timedelta(days=-1, seconds=75600), &#39;-03&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ou seja, o sistema no qual está rodando o python, está com o &lt;em&gt;time zone&lt;/em&gt; -03 em relação ao UTC.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ Atenção, dependendo de como estiver configurado seu sistema, esse resultado poderá ser diferente do meu.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;resumindo&#34;&gt;Resumindo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;É possível usar tanto o &lt;code&gt;timedelta&lt;/code&gt; como &lt;code&gt;TimeZone&lt;/code&gt;, do &lt;code&gt;pytz&lt;/code&gt;, para definir o &lt;code&gt;tzinfo&lt;/code&gt; de uma instância &lt;code&gt;datetime&lt;/code&gt;. Contudo, &lt;strong&gt;é preciso cuidado com relação ao método usado na atribuição do &lt;code&gt;tzinfo&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caso se esteja usando uma instância &lt;code&gt;TimeZone&lt;/code&gt; do &lt;code&gt;pytz&lt;/code&gt;, é indicado usar o método &lt;code&gt;localize&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BR_TIME_ZONE = pytz.timezone(&amp;quot;America/Sao_Paulo&amp;quot;)
date_time_ibject = datetime(2022, 5, 27, 12, 30, 0, 0)
BR_TIME_ZONE.localize(date_time_ibject)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Já usando o &lt;code&gt;timedelta&lt;/code&gt;, pode-se fazê-lo tanto na criação da instância &lt;code&gt;datetime&lt;/code&gt;, quanto usando o método &lt;code&gt;replace&lt;/code&gt; do objeto &lt;code&gt;datetime&lt;/code&gt; já instanciado;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BR_TIME_ZONE = timezone(timedelta(hours=-3))
date_time_object = datetime(2022, 5, 27, 12, 30, 0, 0, tzinfo=BR_TIME_ZONE)
# OU
date_time_object = datetime(2022, 5, 27, 12, 30, 0, 0)
date_time_object.replace(tzinfo=BR_TIME_ZONE)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Os dados de data e hora são sempre armazenados em UTC no PostgreSQL, independente de estarmos ou não usando campos com &lt;em&gt;time zone&lt;/em&gt; conscientes. Logo, ao persistir um dado consciente, o mesmo será convertido e persistido em UTC, mesmo em campos ingênuos. Objetos sem informação de &lt;em&gt;time zone&lt;/em&gt;, serão persistido como tais por se entender já estarem em UTC. A diferença em relação a esses tipos de campos se dá pelo fato do primeiro armazenar a informação do &lt;em&gt;time zone&lt;/em&gt; e o último, não.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outra diferença entre campo consciente e ingênuo se dá nas consultas: Os campos conscientes, ao serem consultados por uma seção com &lt;em&gt;time zone&lt;/em&gt; diferente do padrão (UTC), retornará os dados convertidos ao &lt;em&gt;time zone&lt;/em&gt; da seção;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para definir o &lt;em&gt;time zone&lt;/em&gt; de uma seção, pode-se usar:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# psql
set timezone = &#39;America/Sao_Paulo&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ou&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# SQLAlchemy
engine = create_engine(..., connect_args={&amp;quot;options&amp;quot;: &amp;quot;-c timezone=-3&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Não poderia deixar de agradecer ao &lt;a href=&#34;&#34;&gt;@cuducos&lt;/a&gt; pelo incentivo em resolver os problemas encontrados e ajuda na revisão do texto. Eu acabei encontrando essas soluções antes de ter tempo de seguir a sugestão dele: &amp;ldquo;tentar identificar o como o SQLAlchemy estava fazendo o &lt;code&gt;insert&lt;/code&gt; dos dados e o resgate dos mesmos&amp;rdquo;. Vejo que, de alguma forma, foi o direcionamento que acabei tomando para entender a diferença nos fuso horários retornados pelas consultas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando um sistema para gestão de dados geográficos de forma simples e robusta III</title>
      <link>/post/sistema-dados-geograficos-iii/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/sistema-dados-geograficos-iii/</guid>
      <description>&lt;p&gt;Caso não tenha visto as publicações anteriores, deixo aqui o &lt;em&gt;link&lt;/em&gt; e os temas abordados:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe-/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Na primeira publicação&lt;/a&gt; falo sobre o &lt;a href=&#34;https://django-geojson.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-geojson&lt;/code&gt;&lt;/a&gt; para simular um campo geográfico no models; o &lt;a href=&#34;https://geojson.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geojson&lt;/code&gt;&lt;/a&gt; para criar um objeto da classe &lt;em&gt;geojson&lt;/em&gt; e realizar as validações necessárias para garantir robustez do sistema, e a criação do formulário de registro de dados usando o &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/#modelform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ModelForm&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe--1e/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Na segunda publicação&lt;/a&gt; apresento os validadores de campo do &lt;code&gt;Django&lt;/code&gt; como uma ferramenta fundamental na qualidade dos dados espaciais, &lt;strong&gt;sem depender de infraestrutura SIG (GIS)&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Agora a ideia é implementar um &lt;em&gt;webmap&lt;/em&gt; usando o módulo &lt;a href=&#34;https://django-leaflet.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-leaflet&lt;/code&gt;&lt;/a&gt; para apresentar os fenômenos mapeados com algumas informações no &lt;em&gt;popup&lt;/em&gt; do mapa. Para isso iremos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;usar o &lt;code&gt;GeoJSONLayerView&lt;/code&gt;, do &lt;a href=&#34;https://django-geojson.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-geojson&lt;/code&gt;&lt;/a&gt; para retornar os dados salvos no formato apropriado para exibição no &lt;em&gt;webmap&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;usar o &lt;a href=&#34;https://django-leaflet.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-leaflet&lt;/code&gt;&lt;/a&gt; para, além de implementar o &lt;em&gt;webmap&lt;/em&gt;, podermos usar várias outras ferramentas (&lt;code&gt;widget&lt;/code&gt;);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vamos lá!&lt;/p&gt;
&lt;h2 id=&#34;view-geojsonlayerview&#34;&gt;View GeoJSONLayerView&lt;/h2&gt;
&lt;p&gt;A serialização ou, em inglês &lt;code&gt;serialization&lt;/code&gt;, é o processo/mecanismo de tradução dos objetos armazenados na base de dados em outros formatos (em geral, baseado em texto como, por exemplo, XML ou JSON), para serem enviados e/ou consumidos no processo de &lt;em&gt;request/response&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;No nosso caso isso será importante, pois para apresentar os dados salvos em um &lt;em&gt;webmap&lt;/em&gt;, precisaremos servi-los no formato &lt;code&gt;geojson&lt;/code&gt;. E é aí que o &lt;code&gt;django-geojson&lt;/code&gt; entra. Nós o utilizaremos para fazer a mágica acontecer ao usar a classe &lt;a href=&#34;https://django-geojson.readthedocs.io/en/latest/views.html#geojson-layer-view&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;GeoJSONLayerView&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A classe &lt;code&gt;GeoJSONLayerView&lt;/code&gt; é um &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/topics/class-based-views/mixins/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mixin&lt;/code&gt;&lt;/a&gt; que, em base ao modelo informado do nosso projeto, serializa os dados transformando-os em &lt;code&gt;geojson&lt;/code&gt; e os servindo em uma &lt;code&gt;view&lt;/code&gt;. Acredite, é bastante coisa para apenas algumas linhas de código.&lt;/p&gt;
&lt;p&gt;Para entender a serialização, segue um exemplo&amp;hellip;&lt;/p&gt;
&lt;p&gt;Ao acessar os dados do banco de dados do nosso projeto, temos uma &lt;code&gt;QuerySet&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Fenomeno.objects.all()
&amp;lt;QuerySet [&amp;lt;Fenomeno: fenomeno_teste&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao acessar a geometria de um objeto do banco de dados do nosso projeto, temos um &lt;code&gt;geojson&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; Fenomeno.objects.get(pk=3).geom
{&#39;type&#39;: &#39;Point&#39;, &#39;coordinates&#39;: [-42.0, -22.0]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao serializá-lo com o &lt;code&gt;GeoJSONSerializer&lt;/code&gt;, temos como retorno uma &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7946#section-3.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;FeatureCollection&lt;/code&gt;&lt;/a&gt; seguindo o formato &lt;code&gt;geojson&lt;/code&gt;, tendo como propriedades os campos do &lt;code&gt;model&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from djgeojson.serializers import Serializer as GeoJSONSerializer
&amp;gt;&amp;gt;&amp;gt; GeoJSONSerializer().serialize(Fenomeno.objects.all(), use_natural_keys=True, with_modelname=False)
&#39;{&#39;crs&#39;: {&#39;properties&#39;: {&#39;href&#39;: &#39;http://spatialreference.org/ref/epsg/4326/&#39;,
                        &#39;type&#39;: &#39;proj4&#39;},
         &#39;type&#39;: &#39;link&#39;},
 &#39;features&#39;: [{&#39;geometry&#39;: {&#39;coordinates&#39;: [-42.0, -22.0], &#39;type&#39;: &#39;Point&#39;},
               &#39;id&#39;: 3,
               &#39;properties&#39;: {&#39;data&#39;: &#39;2021-06-22&#39;,
                              &#39;hora&#39;: &#39;02:07:57&#39;,
                              &#39;nome&#39;: &#39;teste&#39;},
               &#39;type&#39;: &#39;Feature&#39;}],
 &#39;type&#39;: &#39;FeatureCollection&#39;}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mais sobre serialização pode ser encontrado &lt;a href=&#34;https://django-portuguese.readthedocs.io/en/1.0/topics/serialization.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aqui&lt;/a&gt; ou &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/contrib/gis/serializers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aqui, com outro exemplo relacionado a dado geográfico usando o GeoDjango&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Então, ciente de toda a mágica por trás do &lt;code&gt;GeoJSONLayerView&lt;/code&gt; e o seu resultado, vamos criar os testes para essa &lt;code&gt;view&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;criando-os-testes-da-view&#34;&gt;Criando os testes da &lt;code&gt;view&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Como estou testando justamente uma &lt;code&gt;view&lt;/code&gt; que serializa o objeto do meu modelo em formato &lt;code&gt;geojson&lt;/code&gt;, precisarei desses dados salvos no banco de dados. Para tanto, vou adicionar ao &lt;code&gt;setUp&lt;/code&gt; do meu &lt;code&gt;TestCase&lt;/code&gt; valores válidos ao banco de dados do teste. Sem isso, não poderemos confirmar se a serialização está ocorrendo de forma correta. E, uma vez salvo, realizo um conjunto básico de testes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Confirmo se o &lt;em&gt;status code&lt;/em&gt; do request (método &amp;ldquo;get&amp;rdquo;) ao &lt;em&gt;path&lt;/em&gt; que pretendo usar para essa views (no caso, &amp;ldquo;/geojson/&amp;quot;), retorna 200, código que indica sucesso no processo de &lt;em&gt;request/response&lt;/em&gt;. &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_HTTP_status_codes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Veja mais sobre os códigos aqui&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Em seguida, confirmo se a resposta recebida é uma &lt;code&gt;FetureCollection&lt;/code&gt; com os dados da instância criada anteriormente.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# testes.py
class FenomenoGeoJsonTest(TestCase):
    def setUp(self):
        Fenomeno.objects.create(
            nome=&amp;quot;Teste&amp;quot;,
            data=&amp;quot;2020-01-01&amp;quot;,
            hora=&amp;quot;09:12:12&amp;quot;,
            geom={&amp;quot;type&amp;quot;: &amp;quot;Point&amp;quot;, &amp;quot;coordinates&amp;quot;: [-42, -22]},
        )

    def teste_geojson_status_code(self):
        self.resp = self.client.get(r(&amp;quot;geojson&amp;quot;))
        self.assertEqual(200, self.resp.status_code)

    def teste_path_geojson_returns_valid_feature_collection(self):
        self.resp = self.client.get(r(&amp;quot;geojson&amp;quot;))
        self.assertEqual(
            self.resp.json(),
            {
                &amp;quot;type&amp;quot;: &amp;quot;FeatureCollection&amp;quot;,
                &amp;quot;features&amp;quot;: [
                    {
                        &amp;quot;type&amp;quot;: &amp;quot;Feature&amp;quot;,
                        &amp;quot;properties&amp;quot;: {
                            &amp;quot;popup_content&amp;quot;: &amp;quot;&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span&amp;gt;Nome: &amp;lt;/span&amp;gt;Teste&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;,
                            &amp;quot;model&amp;quot;: &amp;quot;core.fenomeno&amp;quot;,
                        },
                        &amp;quot;id&amp;quot;: 1,
                        &amp;quot;geometry&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;Point&amp;quot;, &amp;quot;coordinates&amp;quot;: [-42.0, -22.0]},
                    }
                ],
                &amp;quot;crs&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;name&amp;quot;, &amp;quot;properties&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;EPSG:4326&amp;quot;}},
            },
        )

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviamente, ambos testes falharão, pois, ainda não criamos a view e nem a designamos a um &lt;em&gt;path&lt;/em&gt; do nosso sistema.&lt;/p&gt;
&lt;p&gt;Para fazê-los passar, vamos primeiro criar a view: Em &lt;code&gt;views.py&lt;/code&gt; criaremos uma classe nova, herdando da classe &lt;code&gt;GeoJSONLayerView&lt;/code&gt;. Ela será a view responsável por resgatar os dados e servir-nos como uma &lt;code&gt;FeatureCollection&lt;/code&gt; seguindo a estrutura de um &lt;code&gt;geojson&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Um último detalhe é que, como estamos usando um &lt;code&gt;Class Based-View&lt;/code&gt;, ao final a convertemos em view, com o método &lt;code&gt;as_view()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# views.py
from djgeojson.views import GeoJSONLayerView

from map_proj.core.models import Fenomeno


class FenomenoGeoJson(GeoJSONLayerView):
    model = Fenomeno
    properties = (&amp;quot;popup_content&amp;quot;,)


fenomeno_geojson = FenomenoGeoJson.as_view()

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;adicionando-propriedade-para-popup&#34;&gt;Adicionando propriedade para &lt;em&gt;popup&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Percebam que no &lt;code&gt;teste_geojson_FeatureCollection&lt;/code&gt; eu já estou considerando que o &lt;code&gt;geojson&lt;/code&gt; virá com &lt;code&gt;properties&lt;/code&gt; com o nome de &lt;code&gt;popup-content&lt;/code&gt;. Essa &lt;code&gt;property&lt;/code&gt; ainda deverá ser criada no model em questão e poderá ter quantas informações acharmos pertinentes. Se tratam das informações do model a serem apresentadas no &lt;em&gt;popup&lt;/em&gt; do mapa.&lt;/p&gt;
&lt;p&gt;Por agora estou apenas informando o nome do fenômeno mapeado mas, mais à frente, podemos incrementar, adicionando um &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/models/instances/#get-absolute-url&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get_absolute_url&lt;/code&gt;&lt;/a&gt; por exemplo, para poder acessar aos detalhes do fenômeno diretamente a partir do &lt;em&gt;popup&lt;/em&gt; do mapa.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#models.py
...
    @property
    def popup_content(self):
        return self.nome
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;adicionando-um-path-a-view&#34;&gt;Adicionando um &lt;em&gt;path&lt;/em&gt; a &lt;code&gt;view&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Para poder acessar essa view, precisamos incorporá-la na nossa &lt;code&gt;urls.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# urls.py
from django.contrib import admin
from django.urls import path

from map_proj.core.views import fenomeno_geojson # novo!

urlpatterns = [
    path(&amp;quot;admin/&amp;quot;, admin.site.urls),
    path(&amp;quot;geojson/&amp;quot;, fenomeno_geojson, name=&amp;quot;geojson&amp;quot;), # novo!
]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com isso teremos os nossos últimos testes passando. Se ainda assim você tiver curiosidade, pode executar o &lt;code&gt;runserver&lt;/code&gt; e acessar os dados pela &lt;em&gt;url&lt;/em&gt; &lt;code&gt;http://127.0.0.1:8000/geojson/&lt;/code&gt;. O resultado esperado são os dados servidos em &lt;code&gt;geojson&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
                &amp;quot;type&amp;quot;: &amp;quot;FeatureCollection&amp;quot;,
                &amp;quot;features&amp;quot;: [
                    {
                        &amp;quot;type&amp;quot;: &amp;quot;Feature&amp;quot;,
                        &amp;quot;properties&amp;quot;: {
                            &amp;quot;popup_content&amp;quot;: &amp;quot;&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span&amp;gt;Nome: &amp;lt;/span&amp;gt;Teste&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;,
                            &amp;quot;model&amp;quot;: &amp;quot;core.fenomeno&amp;quot;,
                        },
                        &amp;quot;id&amp;quot;: 1,
                        &amp;quot;geometry&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;Point&amp;quot;, &amp;quot;coordinates&amp;quot;: [-42.0, -22.0]},
                    }
                ],
                &amp;quot;crs&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;name&amp;quot;, &amp;quot;properties&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;EPSG:4326&amp;quot;}},
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⚠️ Garanta que você já tenha inserido algum dado ao seu projeto ;)&lt;/p&gt;
&lt;p&gt;Pronto, já temos uma &lt;code&gt;view&lt;/code&gt; nos servindo os dados em formato &lt;code&gt;geojson&lt;/code&gt;. Vamos ao &lt;code&gt;Django-leaflet&lt;/code&gt;, para entender como montar um &lt;em&gt;webmap&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;django-leaflet&#34;&gt;Django-leaflet&lt;/h2&gt;
&lt;p&gt;Para saber mais sobre o &lt;code&gt;django-leaflet&lt;/code&gt;, recomendo dar uma olhada na página &lt;a href=&#34;https://pypi.org/project/django-leaflet/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pypi&lt;/a&gt; e na &lt;a href=&#34;https://django-leaflet.readthedocs.io/en/latest/installation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;documentação&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Você deve estar se perguntando: &amp;ldquo;por quê usar o &lt;code&gt;django-leaflet&lt;/code&gt; se eu posso usar o &lt;a href=&#34;https://leafletjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;leaflet&lt;/code&gt;&lt;/a&gt; &amp;ldquo;puro&amp;rdquo;, já que se trata de uma biblioteca JavaScript para produção do mapa no &lt;em&gt;frontend&lt;/em&gt;?&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Os autores do projeto &lt;code&gt;django-leaflet&lt;/code&gt; deixam alguns pontos que justificam sua adoção na página da documentação. Das quais eu destaco:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Possibilidade de uso das ferramentas de edição de geometría usando os &lt;code&gt;widget&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Fácil integração dos &lt;code&gt;widgets&lt;/code&gt; na página &lt;code&gt;admin&lt;/code&gt; do Django;&lt;/li&gt;
&lt;li&gt;Controle da aparência dos mapas a partir do Django &lt;code&gt;settings.py&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⚠️ E por último, mas não menos importante:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;django-leaflet&lt;/code&gt; é compatível com os campos  &lt;code&gt;django-geojson&lt;/code&gt;, o que permite o uso de dados geográficos sem a necessidade de uma base de dados espaciais. O motivo de toda essa série que tenho produzido :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bem legal! Eles criaram um pacote já compatível com o pacote &lt;code&gt;django-geojson&lt;/code&gt;, que nos permite simular campos geográficos sem a necessidade de toda a infraestrutura de uma base de dados de SIG (PostGIS, por exemplo).&lt;/p&gt;
&lt;p&gt;⚠️ Porém, atenção ao seguinte detalhe:+&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;O &lt;code&gt;django-leaflet&lt;/code&gt; depende da biblioteca &lt;a href=&#34;https://pypi.org/project/GDAL/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GDAL&lt;/a&gt;, não se esqueça de instalá-la antes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instalando-django-leaflet&#34;&gt;Instalando &lt;code&gt;django-leaflet&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pip install django-leaflet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após a sua instalação é necessário incluí-lo no &lt;code&gt;settings.py&lt;/code&gt; como &lt;em&gt;INSTALLED_APPS&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;⚠️ Não esqueça de adicioná-lo ao &lt;code&gt;requirements.txt&lt;/code&gt; do projeto, também.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# settings.py
INSTALLED_APPS = [
    ...
    &#39;djgeojson&#39;,
    &#39;leaflet&#39;, # novo
    ...
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;usando-o-leaflet&#34;&gt;Usando o leaflet&lt;/h3&gt;
&lt;p&gt;Com &lt;code&gt;leaflet&lt;/code&gt; instalado, devemos então:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Na pasta da nossa &lt;em&gt;app&lt;/em&gt;, vamos criar uma pasta chamada &amp;ldquo;templates&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;E nessa pasta, criar um arquivo HTML (neste caso vou chamar de &amp;ldquo;map.html&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;Nessa página vamos carregar as &lt;a href=&#34;https://www.geeksforgeeks.org/django-template-tags/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;template_tags&lt;/code&gt;&lt;/a&gt; do &lt;code&gt;leaflet&lt;/code&gt; para poder usar &lt;code&gt;leaflet_js&lt;/code&gt;, &lt;code&gt;leaflet_css&lt;/code&gt; e o &lt;code&gt;leaflet_map&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nosso &lt;code&gt;map.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% load leaflet_tags %}

&amp;lt;head&amp;gt;
    ...
    {% leaflet_js %}
    {% leaflet_css %}
&amp;lt;/head&amp;gt;
...
&amp;lt;body&amp;gt;
    ...
    {% leaflet_map &amp;quot;yourmap&amp;quot; %}
    ...
&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essas &lt;a href=&#34;https://github.com/makinacorpus/django-leaflet/blob/master/leaflet/templatetags/leaflet_tags.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;template_tags&lt;/code&gt;&lt;/a&gt; irão tentar acessar as configurações do &lt;code&gt;leaflet&lt;/code&gt; presentes no &lt;code&gt;settings.py&lt;/code&gt; da app, caso existam. Do contrário, serão usados valores padrão de configuração. O interessante dessas &lt;code&gt;template_tags&lt;/code&gt; é que com elas podemos customizar tais configurações a cada &lt;em&gt;template&lt;/em&gt;;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Como a ideia é apenas renderizar essa página, vou adicionar ao &lt;code&gt;urls.py&lt;/code&gt; um &lt;em&gt;path&lt;/em&gt; a ela, usando o &lt;a href=&#34;https://docs.djangoproject.com/en/4.0/topics/class-based-views/#basic-examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;TemplateView&lt;/code&gt;&lt;/a&gt;. Com isso, ao receber um &lt;em&gt;request&lt;/em&gt; neste &lt;em&gt;path&lt;/em&gt;, a responsta será direcionada à renderização dessa página:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#urls.py
from django.contrib import admin
from django.urls import path
from django.views.generic import TemplateView

from map_proj.core.views import fenomeno_geojson

urlpatterns = [
    path(&amp;quot;admin/&amp;quot;, admin.site.urls),
    path(&amp;quot;geojson/&amp;quot;, fenomeno_geojson, name=&amp;quot;geojson&amp;quot;),
    path(&amp;quot;map/&amp;quot;, TemplateView.as_view(template_name=&amp;quot;map.html&amp;quot;), name=&amp;quot;map&amp;quot;),
]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Isso já o suficiente para termos nosso &lt;em&gt;webmap&lt;/em&gt; apresentado:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/leaflet_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Imagino que não seja o que esperava, né? Fique calmo. O leaflet buscou as configurações do mapa e, como não encontrou, retornou o mesmo com as configurações padrão. Veremos em breve como alterar as configurações do mapa.&lt;/p&gt;
&lt;p&gt;Antes disso, vamos &amp;ldquo;linkar&amp;rdquo; a view que nos serve o &lt;code&gt;geojson&lt;/code&gt; com os dados salvos no banco com o &lt;em&gt;webmap&lt;/em&gt; em questão, para que os dados sejam apresentados.&lt;/p&gt;
&lt;h3 id=&#34;renderizando-o-geojson-no-mapa&#34;&gt;Renderizando o &lt;code&gt;geojson&lt;/code&gt; no mapa&lt;/h3&gt;
&lt;p&gt;Lembra que temos uma view que serializa os dados armazenados no banco e nos serve como uma &lt;code&gt;FeatureCollection&lt;/code&gt; e que podemos acessar tais dados pelo &lt;em&gt;path&lt;/em&gt; &lt;em&gt;geojson/&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;Então, iremos adicionar um &lt;em&gt;script&lt;/em&gt; à nossa página no qual uma variável &lt;code&gt;dataurl&lt;/code&gt; receberá os dados dessa &lt;em&gt;url&lt;/em&gt; adicionando tais dados ao mapa, assim que o mesmo for inicializado, desencadeando o processo de construção da &lt;em&gt;popup&lt;/em&gt; de cada feição apresentada com sua posterior inserção ao mapa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% load leaflet_tags %}

    &amp;lt;script&amp;gt;
      var dataurl = &#39;{% url &amp;quot;geojson&amp;quot; %}&#39;;

      window.addEventListener(&amp;quot;map:init&amp;quot;, function (event) {
        var map = event.detail.map;
        // Download GeoJSON data with Ajax
        fetch(dataurl)
          .then(function(resp) {
            return resp.json();
          })
          .then(function(data) {
            L.geoJson(data, {
              onEachFeature: function onEachFeature(feature, layer) {
                var props = &amp;quot;&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span&amp;gt;Nome: &amp;lt;/span&amp;gt; &amp;quot; + feature.properties.popup_content + &amp;quot;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;;
                layer.bindPopup(props);
            }}).addTo(map);
          });
      });

    &amp;lt;/script&amp;gt;



&amp;lt;head&amp;gt;
    {% leaflet_js %}
    {% leaflet_css %}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{% leaflet_map &amp;quot;yourmap&amp;quot; %}

&amp;lt;/body&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Veja que, para a criação da variável &lt;code&gt;dataurl&lt;/code&gt;, estamos usando a &lt;code&gt;template_tag&lt;/code&gt; do django:
&lt;code&gt;var dataurl = &#39;{% url &amp;quot;geojson&amp;quot; %}&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Veja mais sobre ela &lt;a href=&#34;https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#url&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Repare também que, neste processo, a cada &lt;code&gt;Feature&lt;/code&gt;, será carregada as suas propriedades a serem apresentadas no &lt;em&gt;popup&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L.geoJson(data, {
              onEachFeature: function onEachFeature(feature, layer) {
                var props = &amp;quot;&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span&amp;gt;Nome: &amp;lt;/span&amp;gt; &amp;quot; + feature.properties.popup_content + &amp;quot;&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;;
                layer.bindPopup(props);
            }}).addTo(map);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com o &lt;code&gt;runserver&lt;/code&gt; em execução, já poderemos ver o nosso mapa com o dado carregado e as propriedades que definimos no &lt;em&gt;popup&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/leaflet_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;⚠️ Garanta que você já tenha inserido algum dado ao seu projeto ;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mudando o tamanho do &lt;em&gt;webmap&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Antes de passarmos às configurações do &lt;code&gt;leaflet&lt;/code&gt;, podemos alterar as dimensões do mapa definindo um &lt;code&gt;style&lt;/code&gt;. Por exemplo, para que o mapa ocupe toda a área possível do navegador, basta adicionarmos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
    #yourmap {
        width: 100%;
        height: 100%;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;./img/leaflet_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;configurações-do-leaflet&#34;&gt;Configurações do leaflet&lt;/h3&gt;
&lt;p&gt;Bom, além das &lt;code&gt;template_tags&lt;/code&gt; do leaflet, o uso do &lt;code&gt;django-leaflet&lt;/code&gt; nos permite definirmos as suas configurações no &lt;code&gt;settings.py&lt;/code&gt; da &lt;code&gt;app&lt;/code&gt;, a partir da seção &lt;code&gt;LEAFLET_CONFIG&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dentre as &lt;a href=&#34;https://django-leaflet.readthedocs.io/en/latest/templates.html#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;configurações possíveis&lt;/a&gt;
, vou usar apenas o par de coordenadas ao qual o mapa deverá estar centralizado por padrão (&lt;code&gt;DEFAULT_CENTER&lt;/code&gt;) e o zoom padrão (&lt;code&gt;DEFAULT_ZOOM&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;LEAFLET_CONFIG = {
    &#39;DEFAULT_CENTER&#39;: (-22, -42),
    &#39;DEFAULT_ZOOM&#39;: 7,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com isso nosso mapa sempre será apresentado centralizado nas coordenadas (-22, -42) e com o zoom 7:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;map_proj/img/leaflet_4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Pronto: com esses três artigos, já temos um sistema com formulário de inserção de dados, com as devidas validações dos dados preenchidos no mesmo, assim como um &lt;em&gt;webmap&lt;/em&gt; apresentando-os ao mundo :-).&lt;/p&gt;
&lt;p&gt;Na próxima publicação vamos ver como fazer o &lt;em&gt;deploy&lt;/em&gt; desse sistema no &lt;a href=&#34;https://www.heroku.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;heroku&lt;/a&gt; 🚀.&lt;/p&gt;
&lt;p&gt;Até lá!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A carreira profissional sob a ótica de um tabuleiro de xadrez</title>
      <link>/post/carreira-e-xadrez/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      <guid>/post/carreira-e-xadrez/</guid>
      <description>&lt;h1 id=&#34;a-carreira-profissional-sob-a-ótica-de-um-tabuleiro-de-xadrez&#34;&gt;A carreira profissional sob a ótica de um tabuleiro de xadrez&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Nota: O presente artigo foi originalmente publicado na primeira edição da &lt;a href=&#34;https://sites.google.com/view/revista-hbnetwork&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;revista HBNetwork&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Aviso antes que seja tarde: não sou formado na área de desenvolvimento, ainda que atue na área de análise de dados e como solucionador de problemas a partir do uso de programação. E tampouco sou um exímio jogador de xadrez. Com relação a este último ponto, como vocês devem se imaginar, estou com as centenas de milhares de pessoas que se permitiram aprender sobre esse lindo jogo depois de assistir à śerie “O gambito da rainha”. Contudo, não considero esses fatos como problema, já que o que pretendo fazer aqui é uma analogia entre o jogo de xadrez e nossa carreira profissional.&lt;/p&gt;
&lt;p&gt;Sim, escrever este texto é uma ousadia de minha parte: além de estar fazendo uma analogia entre dois temas aos quais não me considero apto para tal, se trata apenas de um &lt;strong&gt;exercício mental e hipotético&lt;/strong&gt;. Ciente disto, não terei a menor intenção de esgotar todas as possibilidades metafóricas, nem em tê-las como únicas e verdadeiras. A intenção do texto é, nada mais que convidá-los a pensar o nosso desenvolvimento profissional sob uma nova perspectiva, com o único objetivo de exercitar. Logo, não tenho dúvidas que algumas abordagens aqui adotadas deixarão alguns pontos sem explicação/solução.&lt;/p&gt;
&lt;p&gt;Aviso dado, comento de onde surgiu a ideia: Sou formado em Geografia e, além de atuar nas áreas mencionadas antes, sou também professor de Geopolítica que, assim como os temas das relações internacionais, possui como metáfora principal o jogo do xadrez. Imagino que já tenham escutado algo como “o xadrez geopolítico no oriente médio”. Mas em que sentido, isso? Devo imaginar o presidente do Irã jogando xadrez contra o presidente do Iraque, onde as peças seriam recursos de seus respectivos países? Ou seria o caso de pensar o mundo como um imenso tabuleiro de xadrez onde cada país desempenha um papel e, neste caso, Irã e Iraque seriam algumas das peças em movimentos importantes? Pois é, ambas possibilidades são pertinentes.&lt;/p&gt;
&lt;p&gt;Como até os menos instruídos no jogo já devem saber, cada peça possui habilidades diferentes de movimentação e captura de outras peças. Reconhecer essas diferentes habilidades é importante para sabermos até que ponto nossos colegas poderão nos dar cobertura em alguma movimentação arriscada ou quando será a nossa vez de fazê-lo para que outros se desenvolvam. Ou podemos, ainda, pensar em cada peça como as diferentes habilidades que temos o potencial de desenvolver. É importante conhecê-las, tentar desenvolvê-las mas sem cair em armadilhas.&lt;/p&gt;
&lt;p&gt;E, só para constar, ainda que tenhamos um oponente ao jogar xadrez, não quero dar muita ênfase a ele nas analogias, para não cair numa visão rasa de que estamos lutando contra alguém, ainda que às vezes seja conveniente: você executa alguns movimentos buscando um objetivo (melhoria salarial, por exemplo) e não o alcança, pois o oponente simplesmente não moveu suas peças como você havia pensado, podendo, então, colocar  culpa do seu fracasso no oponente.&lt;/p&gt;
&lt;p&gt;Mas vamos ao que interessa: selecionei três conceitos básicos de xadrez a partir dos quais nos permitirão refletir sobre as possíveis abordagens de desenvolvimento pessoal e profissional:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Peão promovido:&lt;/strong&gt;
Uma iniciativa comum aos que não conhecem alguns conceitos básicos de estratégia é o de tentar a todo custo chegar com o peão ao outro lado do tabuleiro. Cruzando as 8 casas para, então, se tudo der certo, ter o seu peão promovido. Nessa promoção o peão pode se transformar em qualquer uma das outras peças (exceto rei e peão, não faria sentido, né?).&lt;/p&gt;
&lt;p&gt;Seria leviano “apostar todas nossas fichas” em um único peão, peça com movimentação extremamente limitada, que, sozinho, deveria cruzar todo o tabuleiro para então ser promovido a uma peça com maior possibilidade de movimenwtação e que, então, e em teoria, nos daria mais poder. É leviano não apenas pelo risco, mas também pelo fato de dispormos de peças com diferentes habilidades de movimentação.&lt;/p&gt;
&lt;p&gt;Já entenderam onde quero chegar, não?
Aliás, a ideia de promoção do peão vem como uma metáfora à ascensão social a partir de um caminho virtuosos (reto).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reitero: A questão aqui é o custo de oportunidade em sua execução.&lt;/strong&gt; Além de deixar de desenvolver outras peças com diferentes habilidades, acaba-se por expor uma fraqueza pois, ao não poderem retroceder, o peão poderá ficar como “peão isolado “, outro conceito importante do xadrez. Algo que pode ser como “o vale das sombras” que o Henrique Bastos tanto fala… Ainda que o peão seja considerado uma peça de pouco valor, não vale a pena permitir que ela apresente uma debilidade no desenvolvimento do jogo (carreira).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./imagem1_peao_isolado.png&#34; alt=&#34;&#34;&gt;
Imagem: Peão branco na posição e6 está isolado sem proteção de outra peça.&lt;/p&gt;
&lt;p&gt;Como evitar essa debilidade? Existem algumas “estruturas de peões”, onde movem-se diferentes peças dessa categoria de forma que uma dê proteção a outra. Um exemplo está na formação de uma cadeia de peões que, ao estarem em diagonal, acabam por proteger-se de potenciais ataques, não os evitando mas garantindo que ao serem atacados outros poderão contra-atacar. Aliás, uma das defesas mais famosas, chamada de “Defesa Francesa” se baseia nessa proposta. Espírito de equipe e consciência social é tudo, não é mesmo?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./imagem2_cadeia_peoes.png&#34; alt=&#34;&#34;&gt;
Image: Defesa francesa: grupo de peões negros formando uma cadeia de peões em diagonal, tornando o ataque mais arricado.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Domínio do centro:&lt;/strong&gt;
Um conceito importante a ser considerado no xadrez é o de domínio do centro do tabuleiro. Longe de definir qualquer partida, o domínio do centro é a estratégia de posicionar algumas peças de forma a ter ao seu alcance o domínio de mais casas (não quero usar a palavra ameaçar pra não entrar numa visão maniqueísta). Mas dito domínio não pode ser pensado apenas pela presença de uma ou outra peça em posição estratégica, como se uma bandeira garantisse, por si só, a posse de um território. É estratégico ter outras peças (habilidades?) dando cobertura às que estão tentando dominar o centro. Assim como se faz com a cadeia de peões. Afinal, ao tentar dominar o centro, se está, por consequência, se expondo, gerando uma debilidade.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./imagem3_dominio_centro.png&#34; alt=&#34;&#34;&gt;
Imagem: Peças brancas posicionadas de forma a, não apenas dominar o centro (casas marcadas com círculo verde), mas também, com outras peças protegendo os peões mais avançados (setas verdes).&lt;/p&gt;
&lt;p&gt;Para finalizar, acho legal comentar que, ao meu ver, &lt;strong&gt;toda vulnerabilidade mencionada sempre existirá.&lt;/strong&gt; Afinal, “Só não erra quem não tenta”. E é aí que eu acho que entra um pouco essa ideia de &lt;strong&gt;autonomia: reconhecê-las, afinal, ninguém é perfeito, para trabalhá-las de forma a reduzir  a perda potencial.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;O que achou dessas análises? Acrescentaria alguma coisa? Não deixe de dar uma olhada nos demais artigos publicados na &lt;a href=&#34;https://sites.google.com/view/revista-hbnetwork&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;revista HBNetwork&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Links:&lt;/strong&gt;
&lt;a href=&#34;felipesbarros.github.io&#34;&gt;Portifolio&lt;/a&gt;
&lt;a href=&#34;https://github.com/FelipeSBarros&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;
&lt;a href=&#34;https://www.linkedin.com/in/felipesodre/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkedin&lt;/a&gt;
&lt;a href=&#34;https://twitter.com/FelipeSMBarros&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bug buster</title>
      <link>/post/bug-buster/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      <guid>/post/bug-buster/</guid>
      <description>&lt;h3 id=&#34;como-tudo-começou&#34;&gt;Como tudo começou:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Nota do autor: artigo publiciado em 27/04/2022:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Estou trabalhando num projeto onde uma das funções do python é executada e recebe um um parâmtero pelo terminal. Um detalhe é que esse parâmetro é o nome de uma pessoa. Um ponto que não previ no processo de desenvolvimento é que nomes, como qualquer outro elemento textual da lingua portuguesa, podem ter acentos (ou &amp;ldquo;caracteres especiais&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;Pois é, foi praticamente sem querer que vi, olhando os logs produzidos, que os nomes com acento estavam com problema de &lt;code&gt;encoding&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;E assim começou a minha caça ao bug. Uma caça que me tomou um dia e meio. Mas foi de grande aprendizado.&lt;/p&gt;
&lt;h3 id=&#34;um-pouco-do-contexto&#34;&gt;Um pouco do contexto:&lt;/h3&gt;
&lt;p&gt;Antes de descrever essa aventura, comento um pouco o fluxo do programa que apresentou erro:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Uma função é executada pelo terminal e recebe um parâmtero, que é o nome de uma pessoa;&lt;/li&gt;
&lt;li&gt;Esse nome é usado para instanciar um objeto. Logo no &lt;code&gt;__init__&lt;/code&gt; tenho o ponto de acesso ao que foi informado pelo terminal com a incorporação do mesmo como atributo da instância.&lt;/li&gt;
&lt;li&gt;Alguns processamnetos, que não vem ao caso, são realizados;&lt;/li&gt;
&lt;li&gt;O log do processamento realizado é persistirdo numa base de dados usando o &lt;code&gt;SQLAlchemy&lt;/code&gt;, onde a tabela que o recebe possui um campo id e outro json, com os logs organizados em tal formato.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;e-agora-por-onde-começar&#34;&gt;E agora? Por onde começar?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Buscando o bug no terminal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Como o parâmetro estava sendo passado por terminal, achei que o problema estava nesse ponto: no terminal. Primeiro passo: checar o encoding usado pelo sistema. Mas logo vi que estava tudo em &lt;code&gt;utf-8&lt;/code&gt;, o que por sí, não deveria apresentar problema.&lt;/p&gt;
&lt;p&gt;Como o nome estava sendo passado como um parâmetro do sistema a partir de uma variável, aproveitei para checar se o erro não estava aí. Nada que um print e alguns testes no terminal não resolva.  E nada, os nomes armazenados na variáve e passados como parâmetro não sofriam qualquer alteração neste processo inicial.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interseção terminal/python&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Achei, então que o erro estava em alguma incompatibilidade entre o que era passado no terminal e o como o python estava recebendo.&lt;/p&gt;
&lt;p&gt;Segundo passo, então, foi checar o ponto de contato entre terminal e o python. Ler o seguinte trecho, de uma resposta do &lt;em&gt;stackOverFlow&lt;/em&gt; me deu a certeza de que era aí o erro:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When Python does not detect that it is printing to a terminal, sys.stdout.encoding is set to None.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ou seja, quando o python não pode detectar o que está sendo apresentado ao terminal o &lt;code&gt;sys.stdout.encoding&lt;/code&gt; é definido como &lt;code&gt;None&lt;/code&gt;; Ora, estou passando um parametro a partir de uma variável do terminal, logo um string. O Python não consegue identificar o encoding dessa string e está definindo, então o encoding a None, o que deve estar gerando o erro.&lt;/p&gt;
&lt;p&gt;Tentando resolver isso, busquei alguma forma de declarar o encoding&amp;hellip; Cheguei a adicionar ao &lt;code&gt;__init__&lt;/code&gt;, quando a classe é instanciada e recebe o nome da pessoa os métodos, &lt;code&gt;.encode().decode(&#39;utf-8&#39;)&lt;/code&gt; ao objeto que recebe o valor. Parecia que ia funcionar, vejam:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nome = &#39;Felipe Sodré&#39;
b&#39;Felipe Sodr\xc3\xa9&#39;
# e ao adicionar o decode o texto volta ao normal...
nome.encode().decode(&#39;utf-8&#39;)
&#39;Felipe Sodré&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;Meio&amp;rdquo; gambiarra, não? Mas o importante é se funcionar.&lt;/p&gt;
&lt;p&gt;Contudo, o que parecia a solução, foi logo por agua abaixo na primeira rodada de teste. O nome continua com erro de encoding.&lt;/p&gt;
&lt;p&gt;Decidí, então, usar o módulo &lt;code&gt;logging&lt;/code&gt; para apresentar o nome recebido pelo terminal e nome após a classe estar instanciada durante o processamento. Aliás, o &lt;a href=&#34;https://twitter.com/dunossauro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@dunosauro&lt;/a&gt; apresentou &lt;a href=&#34;https://www.youtube.com/watch?v=PGAOqAWuwC0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;uma live&lt;/a&gt; muito boa sobre o uso do &lt;code&gt;logging&lt;/code&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;Bom, ao usar o &lt;code&gt;logging&lt;/code&gt; tive certeza de que estava tentando resolver o erro no ponto errado, todas as mensagens de log estavam sem o tal erro de encoding, mas no log persistido no banco de dados seguia com o maldito erro&amp;hellip;&lt;/p&gt;
&lt;p&gt;Será que o banco de dados está configurado com uma encoding diferente?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No banco de dados&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;✔️ Banco configurado como &amp;lsquo;utf-8&amp;rsquo;;&lt;/p&gt;
&lt;p&gt;Até que me veio uma luz: nas mensagens de log o nome está sem erro. Mas o log que está sendo persistido no banco de dados ( que são algumas dessas mensagens filtradas para monitorar alguns pontos importantes do sistema) é uma compilação salva em um campo JSON.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Bom deve ser nesse ponto, então.&amp;rdquo;, pensei.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reproduzindo o erro em &lt;code&gt;JSON&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parti então para tentar reproduzir esse erro:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;import json
&amp;gt;&amp;gt;&amp;gt;info = {&#39;nome&#39;:&#39;Felipe Sodré&#39;, &#39;idade&#39;:38}
&amp;gt;&amp;gt;&amp;gt;info
{&#39;nome&#39;: &#39;Felipe Sodré&#39;, &#39;idade&#39;: 28}
&amp;gt;&amp;gt;&amp;gt;json.dumps(info)
&#39;{&amp;quot;nome&amp;quot;: &amp;quot;Felipe Sodr\xc3\xa9&amp;quot;, &amp;quot;idade&amp;quot;: 38}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto! Aí está o problema. No processo de conversão do dicionário ao JSON, há algum tipo de conversão que gera o erro de encoding.&lt;/p&gt;
&lt;p&gt;Não levei &amp;ldquo;muito tempo&amp;rdquo; (tempo é relativo, né?) para encontrar que o método &lt;a href=&#34;https://docs.python.org/3/library/json.html#json.dumps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; possui o parâmetro &lt;code&gt;ensure_ascii&lt;/code&gt;, com valor padrão &lt;code&gt;True&lt;/code&gt;, que garante que as &lt;code&gt;strings&lt;/code&gt; do JSON que possuam caracteres não-ASCII estejam com &lt;code&gt;scape&lt;/code&gt;.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If ensure_ascii is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If ensure_ascii is false, these characters will be output as-is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Testei usando o &lt;code&gt;dumps()&lt;/code&gt; com &lt;code&gt;ensur_ascii=False&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;json.dumps(info, ensure_ascii=False)
&#39;{&amp;quot;nome&amp;quot;: &amp;quot;Flávia Duarte Nascimento&amp;quot;, &amp;quot;idade&amp;quot;: 12}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, ponto de erro encontrado. Basta adicionar o parâmetro apra False e tudo se resolveria.&lt;/p&gt;
&lt;p&gt;Mas não foi bem assim, ainda faltava um ponto. Eu não estava gerando o dump e salvando no banco. O que estou fazendo é passar o dado, ainda em dicionário, para o banco usando o &lt;em&gt;SQLAlchemy&lt;/em&gt; e ele cuida disso para mim.&lt;/p&gt;
&lt;p&gt;Como, ou melhor, onde, então, eu devo informar esse &lt;code&gt;ensure_ascii&lt;/code&gt;?&lt;/p&gt;
&lt;h3 id=&#34;enfim-a-solução&#34;&gt;Enfim, a solução:&lt;/h3&gt;
&lt;p&gt;Foi lendo &lt;a href=&#34;https://stackoverflow.com/a/36438671&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;essa responta no SOF&lt;/a&gt; que entendí que como o ORM &lt;em&gt;SQLAlchemy&lt;/em&gt; está cuidadno disso para mim, ele possui um serializador e que o mesmo é, nada mais, nada menos que os métodos &lt;code&gt;jason.dumps()&lt;/code&gt; e &lt;code&gt;json.loads()&lt;/code&gt;, passados na função &lt;a href=&#34;https://docs.sqlalchemy.org/en/14/core/engines.html#sqlalchemy.create_engine&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;create_engine&lt;/code&gt;&lt;/a&gt; como um &lt;em&gt;kwargs&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;engine = create_engine(..., json_serializer=dumps)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;O golpe final foi ao ler a docuementação do  SQLAlchemy sobre &lt;a href=&#34;https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.JSON&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;o tipo de dado JSON&lt;/a&gt; e aprender que podemos customizar o serializador. Olha só o exemplo da documentação, me dando de &amp;ldquo;bandeja&amp;rdquo; a solução para o bug em questão:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;engine = create_engine(
    &amp;quot;sqlite://&amp;quot;,
    json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora sim, vida que segue, graças à persistẽncia e perseverança na caça aos bugs.&lt;/p&gt;
&lt;p&gt;Ah, claro. Essa investigação contou com a ajuda de outros colegas que dedicaram alguns minutos para conversar e propor soluções, tabém. Muito obrigado!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nota do autor: artigo publiciado em 27/04/2022:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Quando achei que estava tudo funcionando e coloquei em produção a correção, eis que me deparo com um novo erro. Dessa vez um &lt;code&gt;TypeError&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise TypeError(f&#39;Object of type {o.__class__.__name__} &#39;
sqlalchemy.exc.StatementError: (builtins.TypeError) Object of type datetime is not JSON serializable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com algumas pesquisas, pude identificar que, como estou indicando um serializador, Todo objeto a ser inluido no JSON passará por ele. Mas, como o próprio erro informa, um objeto &lt;code&gt;datetime&lt;/code&gt; não pode ser seriaizado. E por isso que o método &lt;code&gt;json.dumps()&lt;/code&gt;, além de ter o parâmetro &lt;code&gt;ensure_ascii&lt;/code&gt;, possui um argumento para a serialização padrão.&lt;/p&gt;
&lt;p&gt;Portanto o último bug foi resolvido usando o parâmetro &lt;code&gt;default=str&lt;/code&gt;. Ou seja, o serializador padrãoa pe transformar o objeto a uma classe &lt;em&gt;string&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O codigo ficou, então da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;engine = create_engine(
    &amp;quot;sqlite://&amp;quot;,
    json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False, default=str))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E vocês, que estratégias adotam na caça aos bugs?&lt;/p&gt;
&lt;p&gt;Note: image from &lt;a href=&#34;https://www.mclibre.org/consultar/documentacion/listados/thepracticaldev.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@ThePracticalDev&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hacktoberfest 2021</title>
      <link>/post/hacktoberfest-2021/</link>
      <pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate>
      <guid>/post/hacktoberfest-2021/</guid>
      <description>&lt;h1 id=&#34;hacktoberfest-colaborações-e-aprendizados&#34;&gt;Hacktoberfest: Colaborações e aprendizados&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/hacktoberfest-colabora%C3%A7%C3%B5es-e-aprendizados-felipe-sodr%C3%A9-mendes-barros/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hacktoberfest.digitalocean.com/_nuxt/img/logo-hacktoberfest-full.f42e3b1.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;O &lt;a href=&#34;https://hacktoberfest.digitalocean.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HacktoberFest&lt;/a&gt; é um evento promovido pela Digital Ocean durante o mês de outubro e já está na sua oitava edição. O objetivo é incentivar a colaboração em projetos de código aberto e, claro, como uma forma de democratizar o conhecimento em sistemas de versionamento, como o &lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git&lt;/a&gt;, além de outras tecnologias.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;Ah, e o incentivo vem com a possibilidade de ganhar uma camisa do evento ao ter aprovado quatro &lt;a href=&#34;https://git-scm.com/docs/git-request-pull&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;pull requests&lt;/em&gt;&lt;/a&gt; em repositórios participantes (para participar, basta adicionar a tag &amp;ldquo;Hactoberfest&amp;rdquo; ao repositório ou adicionar a tag &amp;ldquo;Hacktoberfest-accepted&amp;rdquo; no &lt;em&gt;Pull request&lt;/em&gt; em questão).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Não foi minha primeira participação, mas foi a primeira vez que pude colaborar em projetos diferentes daqueles relacionados ao meu trabalho cotidiano. E já fazia algum tempo que tinha interesse em colaborar, mas não sabia como quebrar a inércia. Compartilho neste artigo, alguns projetos desenvolvidos este ano e o que pude aprender nos mesmos.&lt;/p&gt;
&lt;h3 id=&#34;fogo-cruzado&#34;&gt;Fogo Cruzado&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fogocruzado.org.br/wp-content/uploads/2019/05/logo_fogo_cruzado_v2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;O projeto &lt;a href=&#34;https://fogocruzado.org.br/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fogo Cruzado&lt;/a&gt; foi desenvolvido pela &lt;a href=&#34;https://voltdata.info/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Volt Data Lab&lt;/a&gt; e &lt;a href=&#34;https://twitter.com/fogocruzado&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Instituto Fogo Cruzado&lt;/a&gt;, como um sistema &lt;a href=&#34;https://pt.wikipedia.org/wiki/Crowdsourcing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crowdsourcing&lt;/a&gt; para monitoramento dos tiroteios no Rio de Janeiro e/ou em Recife. &lt;a href=&#34;https://fogocruzado.org.br/sobre-a-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O mesmo disponibiliza uma API&lt;/a&gt; para acessar aos dados, bastando criar um usuário, sem custo. E o projeto já tem um pacote para acessar os dados pelo &lt;a href=&#34;https://github.com/voltdatalab/crossfire&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;R&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Como faltava um módulo python para acessar os dados do projeto, decidi fazê-lo durante o #Hacktoberfest. Esse foi o primeiro projeto: um módulo python para acessar os dados da API, direto do python.&lt;/p&gt;
&lt;p&gt;Foi um desafio legal e, até certa forma, simples, pois eu já tinha um modelo de como funcionava o pacote em R. Então o trabalho foi, principalmente &amp;ldquo;traduzir&amp;rdquo; ao python. Com isso aproveitei para refatorar algumas partes do código.&lt;/p&gt;
&lt;p&gt;No geral, posso dizer que ao desenvolver esse projeto, aprendi sobre:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python-poetry (do zero);&lt;/li&gt;
&lt;li&gt;Validação de login usando variáveis do sistema;&lt;/li&gt;
&lt;li&gt;Publicação de módulos no PyPi;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;E fica como desafios para melhor/implementar em breve:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Melhorar o código com &lt;code&gt;type annotation&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Criação de documentação com &lt;code&gt;Sphynx&lt;/code&gt; (se alguém quiser sugerir outra alternativa será bem-vinda);&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pyinaturalist-convert&#34;&gt;PyInaturalist-convert&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/niconoe/pyinaturalist/main/docs/images/pyinaturalist_logo_med.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;O segundo projeto que atuei nesse mês foi no &lt;a href=&#34;https://github.com/JWCook/pyinaturalist-convert&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PyInaturalist-convert&lt;/a&gt;. A história deste módulo é bem interessante e surge de uma demanda pessoal: O &lt;a href=&#34;https://imibio.misiones.gob.ar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IMiBio&lt;/a&gt;, Instituição onde trabalho, está desenvolvendo um projeto com o &lt;a href=&#34;https://www.inaturalist.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;INaturalist&lt;/a&gt;, uma aplicação de &lt;a href=&#34;https://pt.wikipedia.org/wiki/Crowdsourcing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;crowdsourcing&lt;/a&gt; para observação de biodiversidade, e eu tive que criar um sistema que acesse os dados do projeto usando a &lt;a href=&#34;https://github.com/inaturalist/iNaturalistAPI&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API deles&lt;/a&gt;. Com isso, conheci o módulo &lt;a href=&#34;https://github.com/niconoe/pyinaturalist&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PyINaturalist&lt;/a&gt;. Conversando com os desenvolvedores, comentei que seria interessante ter os dados no padrão &lt;a href=&#34;https://dwc.tdwg.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;darwincore&lt;/a&gt;. Um deles achou pertinente e começamos a desenvolver juntos. Contudo, fiquei uns bons meses afastado do projeto e ao voltar, já era um pacote bem estruturado. Por isso, para entender a estrutura do mesmo e saber por onde começar, além de ler as &lt;a href=&#34;https://guides.github.com/features/issues/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issues&lt;/a&gt; abertas, adotei a estratégia de ler os testes&amp;hellip;&lt;/p&gt;
&lt;p&gt;&amp;hellip; E foi lendo os testes que percebi que estavam implementando um objeto geojson, &amp;ldquo;na unha&amp;rdquo;. Como estive estudando sobre o &lt;a href=&#34;https://pypi.org/project/geojson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geojson&lt;/code&gt;&lt;/a&gt; (e, inclusive foi &lt;a href=&#34;https://felipesbarros.github.io/post/criando-um-sistema-para-gestao-de-dados-geograficos-de-forma-simples-e-robusta-ii/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;um dos temas explorados por mim em outros artigos&lt;/a&gt;, propus usá-lo. Com isso, poderíamos usar os métodos de validação já implementados no módulo, garantindo consistência aos dados;&lt;/p&gt;
&lt;p&gt;Ao colaborar no módulo &lt;code&gt;PyInaturalist-converter&lt;/code&gt;, aprendi sobre:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Como colaborar a um projeto já estruturado. Tenho certeza que essa não é uma regra. Mas foi uma boa estratégia começar lendo os testes;&lt;/li&gt;
&lt;li&gt;Mais aprendizados sobre python-poetry :);&lt;/li&gt;
&lt;li&gt;Soube da existência do formatador de código [Black](The Uncompromising Code Formatter);&lt;/li&gt;
&lt;li&gt;Soube da existencia do &lt;a href=&#34;https://pycqa.github.io/isort/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ISORT&lt;/a&gt;, para padronizar os imports;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além desses aprendizados, o autor principal do módulo já tinha configurado no repositório um &lt;a href=&#34;https://docs.github.com/pt/actions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fluxo de ações&lt;/a&gt; e validações bem interessantes. Dessa forma, havia um sistema de validação do que se estava propondo como &lt;a href=&#34;https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;pull request&lt;/code&gt;&lt;/a&gt;. Ainda não tive tempo de me aprofundar, mas já está na lista de estudos futuros&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;análise-espacial-no-frontend&#34;&gt;Análise espacial no &lt;em&gt;frontend&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Uma última atividade que queria compartilhar, não está relacionada a uma contribuição minha, mas sim, um projeto ao qual eu recebi ajuda.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/an%C3%A1lise-espacial-frontend-felipe-sodr%C3%A9-mendes-barros?trk=public_post-content_share-article&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Publiquei recentemente&lt;/a&gt; um artigo apresentando alguns módulos de JavaScript que nos permitem fazer algumas análises espaciais sem depender de uma infraestrutura de servidores de dados e de mapas.&lt;/p&gt;
&lt;p&gt;Eu fui apresentado a essas tecnologias no &lt;a href=&#34;https://2021.foss4g.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FOSS4G 2021&lt;/a&gt; e por pura curiosidade, já que frontend não é a &amp;ldquo;minha praia&amp;rdquo;, comecei a fazer alguns testes como estratégia de estudos, mesmo.&lt;/p&gt;
&lt;p&gt;Pude evoluir bastante com os estudos, mas num momento vi que poderia ser feito muito mais, mas que eu não tinha conhecimento técnico em JS para isso. Não tive dúvidas em contactar um amigo que trabalha com JS e apresentei a ele o que estava tentando fazer. Ele curtiu e acabou colaborando com o projeto, transformando essa prova de conceito numa solução, em algo realmente interessante.&lt;/p&gt;
&lt;p&gt;Percebam que essa colaboração não surgiu pelo Hacktoberfest. Mas por uma mudança de postura minha em me conectar com outras pessoas e apresentar o que eu estava estudando, as &amp;ldquo;minhas dores&amp;rdquo; e o que pretendia fazer.&lt;/p&gt;
&lt;p&gt;Neste projeto estudei e aprendi sobre:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O &lt;a href=&#34;https://github.com/geotiff/georaster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster&lt;/code&gt;&lt;/a&gt;, uma biblioteca JavaScript que nos permite carrregar, e até mesmo criar, dados raster a partir de objetos JavaScript;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/GeoTIFF/georaster-layer-for-leaflet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster-layer-for-leaflet&lt;/code&gt;&lt;/a&gt; que é uma biblioteca que nos permite apresentar dados &lt;code&gt;raster&lt;/code&gt; (a princípio geotif) nos mapas feitos em &lt;a href=&#34;https://leafletjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;leaflet&lt;/code&gt;&lt;/a&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://geoblaze.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geoblaze&lt;/code&gt;&lt;/a&gt; que é um pacote desenvolvido em JavaScript para permitir analisar dados carregados como georaster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como resultado, criamos dois visualizadores de dados &lt;em&gt;raster&lt;/em&gt; apenas com tecnologia &lt;em&gt;frontend&lt;/em&gt;. &lt;a href=&#34;https://felipesbarros.github.io/geoblaze_test/clicking_pixel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;No primeiro o usuário interage com o pixel&lt;/a&gt; (clicando num píxel específico) e o gráfico apresenta o comportamento temporal daquele pixel; &lt;a href=&#34;https://felipesbarros.github.io/geoblaze_test/clicking_polygon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;No segundo visualizador&lt;/a&gt; o usuário clica em um dos estados e o gráfico apresenta o valor médio dos pixels daquele estado ao longo do tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;notas-finais-sobre-hacktoberfest&#34;&gt;Notas finais sobre Hacktoberfest&lt;/h2&gt;
&lt;p&gt;Entendo que muitos &amp;ldquo;torcem o nariz&amp;rdquo; para o Hacktoberfest, pois poucos o utilizam como uma estratégia de estudos, crescimento ou colaboração a projeto de código aberto, que são os objetivos principais. A ideia de escrever sobre as colaborações feitas é justamente destacar que o evento é uma grande estratégia/ferramenta para aprender mais, conectar-se com outros desenvolvedores e se engajar em projetos de código aberto.&lt;/p&gt;
&lt;p&gt;Espero que os meus aprendizados serviam de motivação aos demais. Qualquer coisa, fico à disposição para conversar mais a respeito.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/hacktoberfest-colabora%C3%A7%C3%B5es-e-aprendizados-felipe-sodr%C3%A9-mendes-barros/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Análise espacial no frontend</title>
      <link>/post/analise-espacial-frontend/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      <guid>/post/analise-espacial-frontend/</guid>
      <description>&lt;h1 id=&#34;criando-um-sistema-para-gestão-de-dados-geográficos-de-forma-simples-e-robusta&#34;&gt;Criando um sistema para gestão de dados geográficos de forma simples e robusta&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/an%C3%A1lise-espacial-frontend-felipe-sodr%C3%A9-mendes-barros/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Este ano pude participar do projeto de jornalismo de dados &lt;a href=&#34;https://infoamazonia.org/project/engolindo-fumaca/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Engolindo Fumaça&lt;/a&gt;, desenvolvido pelo &lt;a href=&#34;https://infoamazonia.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoAmazonia&lt;/a&gt;. Foi um projeto bem desafiador que me trouxe vários aprendizados. Muitos deles já viraram artigos, como os de &lt;a href=&#34;https://felipesbarros.github.io/pt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cubo de dados&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ainda que o projeto tenha sido um sucesso (inclusive, foi um dos finalistas do &lt;a href=&#34;https://premio.jornalismodedados.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prêmio de jornalismo de dados Cláudio Weber Abramo&lt;/a&gt; ) alguns desafios ficaram pendentes. Um deles está com a possibilidade de apresentar dados raster em um sistema webmap, sem dispor de grande infraestrutura de SIG, como base de dados e servidor de mapas, PostGIS e geoserver, respectivamente. Afinal, após todo o processo de análise de dados e produção das matérias, era importante apresentar os dados de forma interativa.&lt;/p&gt;
&lt;p&gt;Aliás, desenvolvimento de soluções com dados espaciais com infraestrutura limitada tem sido um tema explorado por mim em &lt;a href=&#34;https://felipesbarros.github.io/pt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;alguns artigos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Então, em resumo, a necessidade era: apresentar as imagens de satélite utilizadas nas reportagens em um mapa dinâmico, sem depender de um servidor de mapas, para que os leitores da matéria pudessem explorar os dados. Algo similar a um &lt;em&gt;dashboard&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Pois foi ao moderar uma sessão da conferência &lt;a href=&#34;https://2021.foss4g.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Free and Open Source Software for Geospatial&lt;/a&gt; (#FOSS4G) deste ano que, sem querer, me deparei com as possíveis soluções. A solução seria transportar a responsabilidade de carregar, apresentar e calcular algumas estatísticas ao &lt;em&gt;frontend&lt;/em&gt;, usando o conjunto de bibliotecas &lt;a href=&#34;https://github.com/geotiff/georaster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/GeoTIFF/georaster-layer-for-leaflet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster-layer-for-leaflet&lt;/code&gt;&lt;/a&gt; e &lt;a href=&#34;https://geoblaze.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geoblaze&lt;/code&gt;&lt;/a&gt;. A apresentação que me dispertou para essas ferramentas foi feita pelo &lt;a href=&#34;https://www.linkedin.com/in/danieljdufour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Dufour&lt;/a&gt; sobre o &lt;a href=&#34;https://geoblaze.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geoblaze&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/geotiff/georaster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster&lt;/code&gt;&lt;/a&gt; é uma biblioteca JavaScript que nos permite carrregar, e até mesmo criar, dados raster a partir de objetos JavaScript;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GeoTIFF/georaster-layer-for-leaflet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;georaster-layer-for-leaflet&lt;/code&gt;&lt;/a&gt; é uma biblioteca que nos permite apresentar dados &lt;code&gt;raster&lt;/code&gt; (a princípio geotif) nos mapas feitos em &lt;a href=&#34;https://leafletjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;leaflet&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://geoblaze.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geoblaze&lt;/code&gt;&lt;/a&gt; é um pacote desenvolvido em JavaScript para permitir analisar dados carregados como georaster.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dessa forma, com essa stack the bibliotecas poderemos carregar uma imagem raster georreferenciada, extrair estatísticas gerais e espaciais, bem como aplicar alguns processamentos, como algebra de bandas e apresentá-las em um webmap &lt;code&gt;leaflet&lt;/code&gt;. Tudo isso sem depender de uma infraestrutura de &lt;em&gt;backend&lt;/em&gt;. Tudo sendo processado no &lt;em&gt;frontend&lt;/em&gt;. Sim, essa solução pode ser limitada para alguns casos. Mas nem todos.&lt;/p&gt;
&lt;p&gt;E, por isso, decidi explorar essa alternativa, ainda que &lt;em&gt;frontend&lt;/em&gt; (e JavaScript) não seja a &amp;ldquo;minha praia&amp;rdquo;. A verdade é que não consegui conter o entusiasmo e parti para uma prova conceitual. &lt;a href=&#34;https://observablehq.com/@felipesbarros/proof_of_concept_geoblaze&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Compartilho a prova de conceito que fiz&lt;/a&gt;, usando o &lt;a href=&#34;https://observablehq.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;observablehq&lt;/a&gt; (uma espécie de &lt;em&gt;jupyter-notebook&lt;/em&gt; para programação &lt;em&gt;frontend&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Aproveitei para consolidar o resultado em uma &lt;em&gt;landingpage&lt;/em&gt;. Nela, além de apresentar o raster, foi possível garantir que o usuário possa interagir com o mesmo, de duas formas distintas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clicando em um &lt;em&gt;pixel&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://felipesbarros.github.io/geoblaze_test/img/landingpage.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ou clicando em um dos polígonos que representam os limites dos estados que compõem a Amazônia Legal. (⚠️ não estamos representando o estado do Maranhão já que o mesmo não é contemplado integramente na Amazônia Legal);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://felipesbarros.github.io/geoblaze_test/img/landingpage_polygon.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Em ambas implementações os valores dos pixels são extraídos &lt;a href=&#34;https://pt.wikipedia.org/wiki/Just_in_time&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;just-in-time&lt;/em&gt;&lt;/a&gt; e o gráfico em &lt;a href=&#34;https://plotly.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;plotly&lt;/a&gt; é atualizado representando o comportamento temporal dos mesmos. Tais dados se referem a &lt;a href=&#34;https://pt.wikipedia.org/wiki/Material_particulado&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Material Particulado &amp;lt; 2.5&lt;/a&gt; do ano de 2020. No gráfico, apresentamos, ainda, o valor máximo sugerido pela Organização Mundial da Saúde (&lt;strong&gt;World Health Organization - WHO&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;Essas duas implementações visam explorar oportunidades diferentes das ferramentas em questão. Separamos os resultados em duas páginas diferentes: &lt;a href=&#34;https://felipesbarros.github.io/geoblaze_test/clicking_pixel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;clicando pixel a pixel&lt;/a&gt;; &lt;a href=&#34;https://felipesbarros.github.io/geoblaze_test/clicking_polygon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;clicando num polígono&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt;E, é lógico: tenho tudo documentado no &lt;a href=&#34;https://github.com/felipesbarros/geoblaze_test/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Não posso deixar de mencionar que o projeto só foi possível com a ajuda do &lt;a href=&#34;https://kylefelipe.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kyle Felipe&lt;/a&gt; quem, inclusive, foi o responsável pela evolução do projeto implementando a solução em JS baseada na seleção de polígonos.&lt;/p&gt;
&lt;p&gt;Espero que seja útil :)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/an%C3%A1lise-espacial-frontend-felipe-sodr%C3%A9-mendes-barros/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando um sistema para gestão de dados geográficos de forma simples e robusta II</title>
      <link>/post/criando-um-sistema-para-gestao-de-dados-geograficos-de-forma-simples-e-robusta-ii/</link>
      <pubDate>Sun, 11 Jul 2021 00:00:00 +0000</pubDate>
      <guid>/post/criando-um-sistema-para-gestao-de-dados-geograficos-de-forma-simples-e-robusta-ii/</guid>
      <description>&lt;h1 id=&#34;criando-um-sistema-para-gestão-de-dados-geográficos-de-forma-simples-e-robusta-ii&#34;&gt;Criando um sistema para gestão de dados geográficos de forma simples e robusta II&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%25C3%25A3o-de-dados-geogr%25C3%25A1ficos-e-felipe--1e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Na &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe-/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;primeira publicação&lt;/a&gt; onde exploro a possibilidade de implementar um sistema de gestão de dados geoespaciais com Django, sem a necessidade de usar um servidor com PostGIS, vimos sobre:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;o &lt;a href=&#34;https://django-geojson.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-geojson&lt;/code&gt;&lt;/a&gt; para simular um campo geográfico no models;&lt;/li&gt;
&lt;li&gt;o &lt;a href=&#34;https://geojson.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geojson&lt;/code&gt;&lt;/a&gt; para criar um objeto da classe &lt;em&gt;geojson&lt;/em&gt; e realizar as validações necessárias para garantir robustez do sistema;&lt;/li&gt;
&lt;li&gt;a criação do formulário de registro de dados usando o &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/#modelform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ModelForm&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora é hora de evoluir e expandir um pouco o sistema criado. Nessa publicação vamos criar validadores de longitude e latitude para poder restringir a inserção de dados a uma determinada região. Com isso, o próximo passo (e artigo) será criar o &lt;em&gt;webmap&lt;/em&gt; no nosso sistema. Mas isso fica para breve.&lt;/p&gt;
&lt;p&gt;Vamos ao que interessa:&lt;/p&gt;
&lt;h2 id=&#34;criando-validadores-de-longitude-e-latitude&#34;&gt;Criando validadores de longitude e latitude&lt;/h2&gt;
&lt;h3 id=&#34;sobre-os-validadores&#34;&gt;Sobre os validadores:&lt;/h3&gt;
&lt;p&gt;Os validadores (&lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/forms/validation/#validators&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;validators&lt;/code&gt;&lt;/a&gt;, em inglês) fazem parte do sistema de validação de formulários e de campos do Django. Ao criarmos campos de uma determinada classe no nosso modelo, como por exemplo &lt;em&gt;integer&lt;/em&gt;, o Django cuidará automaticamente da validação do valor passado a este campo pelo formulário, retornando um erro quando o usuário ingressar um valor de texto no campo em questão, por exemplo. O interessante é que além dos validadores já implementados para cada classe, podemos criar outros, conforme a nossa necessidade.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Por que necessitamos um validador para os campos de &lt;code&gt;latitude&lt;/code&gt; e &lt;code&gt;longitude&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Como estou explorando o desenvolvimento de um sistema de gestão de dados geográficos com recursos limitados, ou seja, sem uma infraestrutura de operações e consultas espaciais, não poderei consultar se o par de coordenadas inserido pelo usuário está contido nos limites de um determinado estado (uma operação clássica com dados geográficos). Não ter essa possibilidade de validação poderá colocar em risco a qualidade do dado inserido.&lt;/p&gt;
&lt;p&gt;E como não se abre mão quando a questão é qualidade, uma saída será a criação de validadores personalizados para os campos de &lt;code&gt;latitude&lt;/code&gt; e &lt;code&gt;longitude&lt;/code&gt;, garantindo que esses possuem valores condizentes à nossa área de interesse.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;O que precisamos saber:&lt;/strong&gt;
os &lt;code&gt;validators&lt;/code&gt; são funções que recebem um valor, apenas (neste caso, o valor inserido pelo usuário no campo a ser validado), que passará por uma lógica de validação retornando um &lt;a href=&#34;https://docs.djangoproject.com/en/3.2/ref/forms/validation/#raising-validation-error&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt; quando o valor inserido não passar na validação. Com o &lt;code&gt;ValidationError&lt;/code&gt; podemos customizar uma mensagem de erro, indicando ao usuário o motivo do valor não ter sido considerado válido, para que o mesmo corrija.&lt;/p&gt;
&lt;p&gt;Então, criarei validadores dos campos de &lt;code&gt;latitude&lt;/code&gt; e &lt;code&gt;longitude&lt;/code&gt; para sempre que entrarem com valores que não contemplem a área do estado do Rio de Janeiro, um &lt;code&gt;ValidationError&lt;/code&gt; será retornado.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ Essa não é uma solução ótima já que, dessa forma, estamos considerando o &lt;em&gt;bounding box&lt;/em&gt; do estado em questão, e com isso haverá áreas onde as coordenadas serão válidas, ainda que não estejam internas ao território estadual. Ainda assim, acredito que seja uma solução boa suficiente para alguns casos, principalmente por não depender de toda infraestrutura de GIS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;O que é um &lt;code&gt;bounding box&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bounding box&lt;/em&gt; poderia ser traduzido por &amp;ldquo;retângulo envolvente&amp;rdquo; do estado, ou de uma feição espacial. Na imagem abaixo, vemos o território do estado do Rio de Janeiro e o retângulo envolvente que limita as suas coordenadas máximas e mínimas de longitude e latitude.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./img/RJ_bbox.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Percebam que, como mencionado antes, o que conseguimos garantir é que os pares de coordenadas estejam em alguma área interna ao retângulo em questão o que não garante que as mesmas estejam no território do estado do Rio de Janeiro.&lt;/p&gt;
&lt;p&gt;Por uma questão de organização, criei no &lt;code&gt;settings.py&lt;/code&gt; do meu projeto  as variáveis com os valores máximos e mínimos de latitude e longitude. Essa proposta surgiu do &lt;a href=&#34;https://twitter.com/cuducos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;cuducos&lt;/code&gt;&lt;/a&gt;, e achei que valia a pena implementar. Entendo que é mais organizado e evita possíveis falhas humanas, caso os mesmos valores tenham que ser usados em outras partes do sistema.&lt;/p&gt;
&lt;p&gt;Ao fim do meu &lt;code&gt;settings.py&lt;/code&gt;, adicionei:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# settings.py
BOUNDING_BOX_LAT_MAX = -20.764962
BOUNDING_BOX_LAT_MIN = -23.366868
BOUNDING_BOX_LON_MAX = -40.95975
BOUNDING_BOX_LON_MIN = -44.887212
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora, sim. Vamos criar os testes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;se você não entendeu o motivo pelo qual eu começo criando testes, dá uma olhada na &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe-/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;primeira publicação&lt;/a&gt;. Nela comento um pouco sobre a abordagem &lt;em&gt;Test Driven Development (TDD)&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;criando-os-testes&#34;&gt;Criando os testes:&lt;/h2&gt;
&lt;p&gt;No &lt;code&gt;tests.py&lt;/code&gt;, criei uma nova classe de teste &lt;code&gt;TestCase&lt;/code&gt;, com o objetivo de testar os validadores simulando o uso do &lt;code&gt;FenomenoForm&lt;/code&gt;. Por isso criei &lt;a href=&#34;https://realpython.com/instance-class-and-static-methods-demystified/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;staticmethod&lt;/code&gt;&lt;/a&gt; chamado &lt;code&gt;create_form&lt;/code&gt; que cria um dicionário com chaves e valores válidos do formulário em questão, que ao receber um conjunto de argumentos nomeados &lt;a href=&#34;https://realpython.com/python-kwargs-and-args/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;**kwargs&lt;/code&gt;&lt;/a&gt; terá tais argumentos atualizados e usados para instanciar e retornar o &lt;code&gt;FenomenoForm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fiz isso para, a cada teste, ter uma instância do &lt;code&gt;FenoenoForm&lt;/code&gt; alterando apenas os campos que quero simular valores a serem validados, sem ter que passar sempre todos os valores do &lt;code&gt;ModelForm&lt;/code&gt;. Assim, eu posso criar diferentes métodos de &lt;em&gt;Test Case&lt;/em&gt;, usando o método criado anteriormente alterando o valor inicial a um inválido, testando se de fato um &lt;code&gt;ValidationError&lt;/code&gt; é retornado.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# tests.py
class FenomenoFormValidatorsTest(TestCase):
    @staticmethod
    def create_form(**kwargs):
        valid_form = {
            &#39;nome&#39;: &#39;Teste&#39;,
            &#39;data&#39;: &#39;2020-01-01&#39;,
            &#39;hora&#39;: &#39;09:12:12&#39;,
            &#39;longitude&#39;: -42,
            &#39;latitude&#39;: -21}

        valid_form.update(**kwargs)
        form = FenomenoForm(valid_form)
        return form

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nos métodos de teste uso primeiro o &lt;code&gt;assertFalse&lt;/code&gt; do método de validação do formulário (&lt;code&gt;form.is_valid()&lt;/code&gt;) para confirmar que o mesmo não é valido para, em seguida, testar com o &lt;code&gt;assertEqual&lt;/code&gt; se o texto da mensagem de erro é o que esperamos. Veja o link a seguir para saber sobre outros &lt;a href=&#34;https://docs.python.org/3/library/unittest.html#unittest.TestCase.debug&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;assertions&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# tests.py
    def test_max_longitude_raises_error(self):
        form = self.create_form(longitude=&#39;-45&#39;)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors[&amp;quot;longitude&amp;quot;][0], &#39;Coordenada longitude fora do contexto do estado do Rio de Janeiro&#39;)

    def test_min_longitude_raises_error(self):
        form = self.create_form(longitude=&#39;-40&#39;)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors[&amp;quot;longitude&amp;quot;][0], &#39;Coordenada longitude fora do contexto do estado do Rio de Janeiro&#39;)

    def test_max_latitude_raises_error(self):
        form = self.create_form(latitude=&#39;-24&#39;)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors[&amp;quot;latitude&amp;quot;][0], &#39;Coordenada latitude fora do contexto do estado do Rio de Janeiro&#39;)

    def test_min_latitude_raises_error(self):
        form = self.create_form(latitude=&#39;-19&#39;)
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors[&amp;quot;latitude&amp;quot;][0], &#39;Coordenada latitude fora do contexto do estado do Rio de Janeiro&#39;)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fazemos rodar os testes e teremos erros como esses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Creating test database for alias &#39;default&#39;...
System check identified no issues (0 silenced).
...E.E..
======================================================================
ERROR: test_max_latitude (map_proj.core.tests.FenomenoFormValidatorsTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;/media/felipe/DATA/Repos/Django_Leaflet_Test/map_proj/core/tests.py&amp;quot;, line 78, in test_max_latitude
    self.assertEqual(form.errors[&amp;quot;latitude&amp;quot;][0], &#39;Coordenada latitude fora do contexto do estado do Rio de Janeiro&#39;)
KeyError: &#39;latitude&#39;

======================================================================
ERROR: test_min_latitude (map_proj.core.tests.FenomenoFormValidatorsTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &amp;quot;/media/felipe/DATA/Repos/Django_Leaflet_Test/map_proj/core/tests.py&amp;quot;, line 83, in test_min_latitude
    self.assertEqual(form.errors[&amp;quot;latitude&amp;quot;][0], &#39;Coordenada latitude fora do contexto do estado do Rio de Janeiro&#39;)
KeyError: &#39;latitude&#39;

----------------------------------------------------------------------
Ran 8 tests in 0.012s

FAILED (errors=2)
Destroying test database for alias &#39;default&#39;...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ou seja, o &lt;code&gt;forms&lt;/code&gt; após ser validado deveria conter um atributo &lt;em&gt;errors&lt;/em&gt; tendo como chave o nome do campo que apresentou dados inválidos. Como não temos os validadores criados, nenhum erro de validação foi acusado no campo de &lt;code&gt;latitude&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;criando-e-usando-validadores&#34;&gt;Criando e usando validadores:&lt;/h2&gt;
&lt;p&gt;Para superá-los criamos, enfim, os validadores em um arquivo &lt;code&gt;validators.py&lt;/code&gt;. Percebam que é nesse ponto que usarei os valores máximos e mínimos de latitude e longitude adicionados no &lt;code&gt;settings.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# validators.py
from django.core.exceptions import ValidationError
from django.conf import settings


def validate_longitude(lon):
    if lon &amp;lt; settings.BOUNDING_BOX_LON_MIN or lon &amp;gt; settings.BOUNDING_BOX_LON_MAX:
        raise ValidationError(&amp;quot;Coordenada longitude fora do contexto do estado do Rio de Janeiro&amp;quot;, &amp;quot;erro longitude&amp;quot;)

def validate_latitude(lat):
    if lat &amp;lt; settings.BOUNDING_BOX_LAT_MIN or lat &amp;gt; settings.BOUNDING_BOX_LAT_MAX:
        raise ValidationError(&amp;quot;Coordenada latitude fora do contexto do estado do Rio de Janeiro&amp;quot;, &amp;quot;erro latitude&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com esses validadores estou garantindo que ambos latitude e longitude estejam na área de interesse e, caso contrário, retorno um erro informando ao usuário.&lt;/p&gt;
&lt;p&gt;E é preciso adicioná-los ao &lt;code&gt;forms.py&lt;/code&gt; para que sejam usados:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# forms.py
from map_proj.core.validators import validate_longitude, validate_latitude

class FenomenoForm(ModelForm):
    longitude = FloatField(validators=[validate_longitude])
    latitude = FloatField(validators=[validate_latitude])
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No desenvolvimento dessa solução percebi pelos testes criados que, ao informar uma latitude ou longitude que não passe pela validação, a criação do campo &lt;code&gt;geom&lt;/code&gt; se tornava inválido por não receber um desses valores, gerando dois erros: o de validação do campo e o de validação do campo &lt;code&gt;geom&lt;/code&gt;. Lembre-se que é no método &lt;code&gt;clean&lt;/code&gt; do formulário que o campo &lt;code&gt;geom&lt;/code&gt; recebe os valores de &lt;code&gt;longitude&lt;/code&gt; e &lt;code&gt;latitude&lt;/code&gt; formando uma classe &lt;code&gt;geojson&lt;/code&gt; para, logo em seguida ser validado.&lt;/p&gt;
&lt;p&gt;Para evitar isso, alterei o método clean de forma garantir que o campo &lt;code&gt;geom&lt;/code&gt; só seja criado e validado, quando ambos valores (&lt;code&gt;longitude&lt;/code&gt; e &lt;code&gt;latitude&lt;/code&gt;) existirem. Ou seja, tenham passado pelos validadores sem erro.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#forms.py
    def clean(self):
        cleaned_data = super().clean()
        lon = cleaned_data.get(&#39;longitude&#39;)
        lat = cleaned_data.get(&#39;latitude&#39;)
        if not all((lon, lat)):
            raise ValidationError(&#39;Erro em latitude ou longitude&#39;)
        
        cleaned_data[&#39;geom&#39;] = Point((lon, lat))
        if not cleaned_data[&#39;geom&#39;].is_valid:
                raise ValidationError(&#39;Geometria inválida&#39;)
        
        return cleaned_data

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Outro ponto (na verdade, erro) importante que só percebi a partir dos testes é que no &lt;code&gt;forms.py&lt;/code&gt; eu não estava considerando o campo &lt;code&gt;geom&lt;/code&gt; na lista de &lt;code&gt;fields&lt;/code&gt; a serem usados. Com isso o mesmo não é passado ao banco de dados, mesmo passando pelo método &lt;code&gt;clean&lt;/code&gt; que o cria.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Por esse motivo, tive que alterar algumas coisas no &lt;code&gt;forms.py&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inseri o campo &lt;code&gt;geom&lt;/code&gt; à tupla de &lt;code&gt;fields&lt;/code&gt; do &lt;code&gt;forms.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Inseri o campo &lt;code&gt;geom&lt;/code&gt; com um widget de &lt;code&gt;HiddenInput&lt;/code&gt;. Esse último, o fiz por se tratar de um campo que não quero expor ao usuário, já que será criado automaticamente no método &lt;code&gt;clean&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finalmente, a classe &lt;code&gt;Meta&lt;/code&gt; do &lt;code&gt;forms.py&lt;/code&gt; ficou da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    class Meta:
        model = Fenomeno
        fields = (&#39;nome&#39;, &#39;data&#39;, &#39;hora&#39;, &#39;latitude&#39;, &#39;longitude&#39;, &#39;geom&#39;)
        widgets = {&#39;geom&#39;: HiddenInput()}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, com tudo isso que fizemos, já temos um sistema que, apesar de não poder fazer consultas espaciais, é capaz de validar os campos de &lt;code&gt;latitude&lt;/code&gt; e &lt;code&gt;longitude&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;No próximo artigo, vou abordar sobre o que está por trás de toda mágica de um webmap, usando o módulo &lt;a href=&#34;https://django-leaflet.readthedocs.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-leaflet&lt;/code&gt;&lt;/a&gt;. Enquanto isso, dê uma olhada &lt;a href=&#34;http://felipesbarros.github.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;no que tenho desenvolvido.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%25C3%25A3o-de-dados-geogr%25C3%25A1ficos-e-felipe--1e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando um sistema para gestão de dados geográficos de forma simples e robusta</title>
      <link>/post/criando-um-sistema-para-gestao-de-dados-geograficos-de-forma-simples-e-robusta/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
      <guid>/post/criando-um-sistema-para-gestao-de-dados-geograficos-de-forma-simples-e-robusta/</guid>
      <description>&lt;h1 id=&#34;criando-um-sistema-para-gestão-de-dados-geográficos-de-forma-simples-e-robusta&#34;&gt;Criando um sistema para gestão de dados geográficos de forma simples e robusta&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe-/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Há algum tempo comecei a estudar sobre desenvolvimento de sistema com Python, usando a framework Django. Decidi expor alguns aprendizados em uma serie de artigos. A ideia é que esses textos me ajudem na consolidação do conhecimento e, ao tê-los publicado, ajudar a outros que tenham interesse na área.&lt;/p&gt;
&lt;p&gt;Aproveito para deixar meu agradecimento ao Cuducos que, tanto neste artigo, como em todos meus estudos tem sido um grande mentor. Vamos ao que interessa:&lt;/p&gt;
&lt;p&gt;Por simples, entende-se:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Um sistema sem a necessidade da instalação e configuração de base de dados PostgreSQL/GIS, Geoserver, etc;&lt;/li&gt;
&lt;li&gt;Um sistema clássico tipo &lt;em&gt;Create&lt;/em&gt;, &lt;em&gt;Retrieve&lt;/em&gt;, &lt;em&gt;Update&lt;/em&gt;, &lt;em&gt;Delete&lt;/em&gt; (CRUD) para dados geográficos;&lt;/li&gt;
&lt;li&gt;Um sistema que não demande operações e consultas espaciais;&lt;/li&gt;
&lt;li&gt;Mas um sistema que garanta a qualidade na gestão dos dados geográficos;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;visão-geral-da-proposta&#34;&gt;Visão geral da proposta:&lt;/h3&gt;
&lt;p&gt;Vamos criar um ambiente virtual Python e instalar a framework Django, para criar o sistema, assim como alguns módulos como &lt;a href=&#34;https://pypi.org/project/jsonfield/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;jsonfield&lt;/code&gt;&lt;/a&gt;, que nos vai habilitar a criação de campos &lt;code&gt;JSON&lt;/code&gt; em nossa base de dados; &lt;a href=&#34;https://pypi.org/project/django-geojson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;django-geojson&lt;/code&gt;&lt;/a&gt;, que depende do &lt;code&gt;jsonfield&lt;/code&gt; e será responsável por habilitar instâncias de dados geográficos, baseando-se em &lt;code&gt;JSON&lt;/code&gt;; &lt;a href=&#34;https://pypi.org/project/geojson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geojson&lt;/code&gt;&lt;/a&gt;, que possui todas as regras &lt;em&gt;básicas&lt;/em&gt; de validação de dados geográficos, usando a estrutura homônima, &lt;a href=&#34;https://geojson.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;geojson&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;O uso desses três módulos nos permitirá o desenvolvimento de um sistema de gestão de dados geográficos sem a necessidade de termos instalado um sistema de gerenciamento de dados geográficos, como o PostGIS. Sim, nosso sistema será bem limitado a algumas tarefas. Mas em contrapartida, poderemos desenvolvê-lo e implementar soluções &amp;ldquo;corriqueiras&amp;rdquo; de forma facilitada.&lt;/p&gt;
&lt;p&gt;No presente exemplo estarei usando &lt;a href=&#34;https://www.sqlite.org/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SQLite&lt;/a&gt;, como base de dados.&lt;/p&gt;
&lt;p&gt;Nosso projeto se chamará de &lt;em&gt;map_proj&lt;/em&gt;. E nele vou criar uma app, dentro da pasta do meu projeto &lt;code&gt;Django&lt;/code&gt;, chamada &lt;code&gt;core&lt;/code&gt;. Essa organização e nomenclatura usada, vem das sugestões do &lt;a href=&#34;https://github.com/okfn-brasil/jarbas/issues/28#issuecomment-256117262&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Henrique Bastos&lt;/a&gt;. Afinal, o sistema está nascendo. Ainda que eu tenha uma ideia do que ele será, é interessante iniciar com uma aplicação &amp;ldquo;genérica&amp;rdquo; e a partir do momento que o sistema se torne complexo, poderemos desacoplá-la em diferentes aplicações.&lt;/p&gt;
&lt;h3 id=&#34;criando-ambiente-de-desenvolvimento-projeto-e-nossa-app&#34;&gt;Criando ambiente de desenvolvimento, projeto e nossa app:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;python -m venv .djleaflet # cria ambiente virtual python
# ativando o ambiente virtual:
source ./venv/bin/activate

# atualizando o pip
pip install --upgrade pip

# intalando os módulos a serem usados
pip install django jsonfield django-geojson geojson

# criando projeto
django-admin startproject map_proj .

# criando app dentro do projeto
cd map_proj
python manage.py startapp core

# criando a base de dados inicial
python manage.py migrate 

# criando superusuário
python manage.py createsuperuser 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;adicionando-os-módulos-e-a-app-ao-projeto&#34;&gt;Adicionando os módulos e a app ao projeto&lt;/h4&gt;
&lt;p&gt;Agora é adicionar ao &lt;code&gt;map_proj/settings.py&lt;/code&gt;, a app criada e os módulos que usaremos.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# setting.py
INSTALLED_APPS = [
    ...
    &#39;djgeojson&#39;,
    &#39;map_proj.core&#39;,
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perceba que para poder acessar as classes de alto nível criadas pelo pacote &lt;code&gt;djgeojson&lt;/code&gt;, teremos que adicioná-lo ao &lt;code&gt;INSTALLED_APPS&lt;/code&gt; do &lt;code&gt;settings.py&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;criando-a-base-de-dados&#34;&gt;Criando a base de dados&lt;/h3&gt;
&lt;p&gt;Ainda que eu concorde com o Henrique Bastos, que a visão de começar os projetos Django pelo &lt;code&gt;models.py&lt;/code&gt; é um tanto &amp;ldquo;perigosa&amp;rdquo;, por colocar ênfase em uma parte da app e, em muitos casos, negligenciar vários outros atributos e ferramentas que o Django nos oferece, irei desconsiderar sua abordagem. Afinal, o objetivo deste artigo não é explorar todo o potencial do Django, mas sim apresentar uma solução simples no desenvolvimento e implementação de um sistema de gestão de dados geográficos para servir como ferramenta de estudo e projeto prático.&lt;/p&gt;
&lt;p&gt;Em &lt;code&gt;models.py&lt;/code&gt; usaremos instâncias de alto nível que o Django nos brinda para criar e configurar os campos e as tabelas que teremos em nosso sistema, bem como alguns comportamentos do sistema.&lt;/p&gt;
&lt;p&gt;Como estou desenvolvendo um sistema multi propósito, vou tentar mantê-lo bem genérico. A ideia é que vocês possam imaginar o que adequar para um sistema especialista na sua área de interesse. Vou criar, então, uma tabela para mapear &amp;ldquo;fenômenos&amp;rdquo; (quaisquer). Esse modelo terá os campos &lt;em&gt;nome&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;hora&lt;/em&gt; e &lt;em&gt;geometria&lt;/em&gt;, a qual será uma instância de &lt;code&gt;PointField&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;PointField&lt;/code&gt; é uma classe criada pelo &lt;code&gt;djgeojson&lt;/code&gt; que nos permite usar um campo para dados geográficos sem ter toda a infraestrutura do PostGIS, instalada, por exemplo. Nesse caso, estou simulando um campo de ponto, mas, de acordo com a documentação do pacote, todas as geometrias usadas em dados espaciais são suportadas:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All geometry types are supported and respectively validated : GeometryField, PointField, MultiPointField, LineStringField, MultiLineStringField, PolygonField, MultiPolygonField, GeometryCollectionField. ( &lt;a href=&#34;https://django-geojson.readthedocs.io/en/latest/models.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;djgeojson&lt;/code&gt;&lt;/a&gt; )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# models.py
from django.db import models
from djgeojson.fields import PointField


class Fenomeno(models.Model):
    nome = models.CharField(max_length=100,
                            verbose_name=&#39;Fenomeno mapeado&#39;)
    data = models.DateField(verbose_name=&#39;Data da observação&#39;)
    hora = models.TimeField()
    geom = PointField(blank=True)

    def __str__(self):
        return self.nome

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Percebam que eu importo de &lt;code&gt;djgeojson&lt;/code&gt; a classe &lt;code&gt;PointField&lt;/code&gt;. O que o &lt;code&gt;django-geojson&lt;/code&gt; fez foi criar uma classe [com estrutura de dados geográfico] de alto nível, mas que no banco de dados será armazenado em um campo &lt;code&gt;JSON&lt;/code&gt;. Vale a pena deixar claro: não espero que o usuário do meu sistema saiba preencher o campo &lt;code&gt;geom&lt;/code&gt; em formato &lt;code&gt;JSON&lt;/code&gt;. Por isso, criarei no &lt;code&gt;forms.py&lt;/code&gt;, os campos &lt;em&gt;latitude&lt;/em&gt; e &lt;em&gt;longitude&lt;/em&gt; e a partir deles, o campo geom será preenchido. Detalharei esse processo mais adiante.&lt;/p&gt;
&lt;p&gt;Pronto, já temos o modelo da &amp;lsquo;tabela de dados &amp;ldquo;geográficos&amp;rdquo;&amp;rsquo;, mas esse modelo ainda não foi registrado em nossa base. Para isso:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O &lt;code&gt;makemigrations&lt;/code&gt; analisa o &lt;code&gt;models.py&lt;/code&gt; e o compara com a versão anterior identificando as alterações e criando um arquivo que será executado pelo &lt;code&gt;migrate&lt;/code&gt;, aplicando tais alterações ao banco de dados. Aprendi com o Henrique Bastos e &lt;a href=&#34;https://twitter.com/cuducos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cuducos&lt;/a&gt; que o migrate é um sistema de versionamento da estrutura do banco de dados, permitindo retroceder, quando necessário, a outras versões.&lt;/p&gt;
&lt;h3 id=&#34;criando-o-formulário&#34;&gt;Criando o formulário&lt;/h3&gt;
&lt;p&gt;Vou aproveitar algumas &amp;ldquo;pilhas já incluídas&amp;rdquo; do Django, ao usar o &lt;code&gt;ModelForm&lt;/code&gt; para criar o formulário para o carregamento de dados. O &lt;code&gt;ModelForm&lt;/code&gt; facilita esse processo.&lt;/p&gt;
&lt;p&gt;Aliás, é importante pensar que os formulários do Django vão muito além da &amp;ldquo;carga de dados&amp;rdquo;, já que são os responsáveis por cuidar da interação com o usuário e o(s) processo(s) de validação e limpeza dos dados preenchidos.&lt;/p&gt;
&lt;p&gt;Digo isso, pois ao meu &lt;code&gt;FenomenosForm&lt;/code&gt;, eu sobreescrevo o método &lt;code&gt;clean()&lt;/code&gt;, que cuida da validação e limpeza do formulário e incluo nele:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a construção dos dados do campo &lt;code&gt;geom&lt;/code&gt; a partir dos valores dos campos de &lt;em&gt;latitude&lt;/em&gt; e &lt;em&gt;longitude&lt;/em&gt; (criados exclusivamente para a gerção do campo geom);&lt;/li&gt;
&lt;li&gt;a validação do campo geom;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# forms.py
from django.core.exceptions import ValidationError
from django.forms import ModelForm, FloatField
from map_proj.core.models import Fenomeno
from geojson import Point


class FenomenoForm(ModelForm):
    longitude = FloatField()
    latitude = FloatField()
    class Meta:
        model = Fenomeno
        fields = (&#39;nome&#39;, &#39;data&#39;, &#39;hora&#39;, &#39;latitude&#39;, &#39;longitude&#39;)

    def clean(self):
        cleaned_data = super().clean()
        lon = cleaned_data.get(&#39;longitude&#39;)
        lat = cleaned_data.get(&#39;latitude&#39;)
        cleaned_data[&#39;geom&#39;] = Point((lon, lat))

        if not cleaned_data[&#39;geom&#39;].is_valid:
            raise ValidationError(&#39;Geometria inválida&#39;)
        return cleaned_data

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ainda que pareça simples, não foi fácil chegar a essa estratégia de estruturação dos &lt;code&gt;models&lt;/code&gt; e &lt;code&gt;forms&lt;/code&gt;. Contei com a ajuda e paciencia do &lt;a href=&#34;https://twitter.com/cuducos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cuducos&lt;/a&gt;. Inicialmente eu mantinha latitude e longitude no meu &lt;code&gt;models&lt;/code&gt;. Mas fazendo assim, além de ter uma redundância de dados e uma abertura a erros potenciais, estaria armazenando dados que não devo usar depois de contruir o campo geom. Uma alternativa, discutida com o Cuducos foi de ter tanto &lt;em&gt;latitude&lt;/em&gt; como &lt;em&gt;longitude&lt;/em&gt; no &lt;code&gt;models&lt;/code&gt;, mas o atributo &lt;code&gt;geom&lt;/code&gt; como &lt;a href=&#34;https://docs.python.org/3/howto/descriptor.html#properties&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;propriedade&lt;/a&gt;. Ainda que seja uma estratégia consistente, a redundância se mantém.&lt;/p&gt;
&lt;p&gt;O processo de validação do campo &lt;code&gt;geom&lt;/code&gt; também foi fruto de muita discussão. De forma resumida, percebi que o &lt;code&gt;djgeojson&lt;/code&gt; apenas valida o tipo de geometria do campo e não a sua consistência. Ao conversar com os desenvolvedores, me disseram que toda a lógica de validação de objetos &lt;code&gt;geojson&lt;/code&gt; estavam sendo centralizados no módulo homônimo.&lt;/p&gt;
&lt;p&gt;Por isso eu carrego a classe &lt;code&gt;Point&lt;/code&gt; do módulo &lt;code&gt;geojson&lt;/code&gt; e designo o campo &lt;code&gt;geom&lt;/code&gt; como instância dessa classe. Assim, passo a poder contar com um processo de validação mais consistente, como o método &lt;code&gt;is_valid&lt;/code&gt;, usado anteriormente.&lt;/p&gt;
&lt;h4 id=&#34;mas-e-o-teste&#34;&gt;Mas e o teste?&lt;/h4&gt;
&lt;p&gt;Pois é, eu adoraria apresentar isso usando a abordagem &lt;em&gt;Test Driven Development (TDD)&lt;/em&gt;. Mas, talvez pela falta de prática, conhecimento e etc, vou apenas apontar onde e como eu testaria esse sistema. Faço isso como uma forma de estudo, mesmo. Também me pareceu complicado apresentar a abordagem TDD em um artigo, já que a mesma se faz de forma incremental.&lt;/p&gt;
&lt;h5 id=&#34;sobre-tdd&#34;&gt;Sobre TDD&lt;/h5&gt;
&lt;p&gt;Com o Henrique Bastos e toda a comunidade do &lt;a href=&#34;https://medium.com/welcome-to-the-django/o-wttd-%C3%A9-tudo-que-eu-ensinaria-sobre-prop%C3%B3sito-de-vida-para-mim-mesmo-se-pudesse-voltar-no-tempo-d73e516f911c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Welcome to The Django&lt;/em&gt;&lt;/a&gt; vi que essa abordagem é tanto filosófica quanto técnica. É praticamente &amp;ldquo;Chora agora, ri depois&amp;rdquo;, mas sem a parte de chorar. Pois com o tempo as coisas ficam mais claras&amp;hellip; Alguns pontos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O erro não é para ser evitado no processo de desenvolvimento, mas sim quando estive em produção. Logo,&lt;/li&gt;
&lt;li&gt;Entenda o que você quer do sistema, crie um teste antes de implementar e deixe o erro te guiar até ter o que deseja;&lt;/li&gt;
&lt;li&gt;Teste o comportamento esperado e não cada elemento do sistema;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sem mais delongas:&lt;/p&gt;
&lt;h5 id=&#34;o-que-testar&#34;&gt;O que testar?&lt;/h5&gt;
&lt;p&gt;Vamos usar o arquivo &lt;code&gt;tests.py&lt;/code&gt; e  criar nossos testes lá.
Ao abrir vocês vão ver que já está o comando importando o &lt;code&gt;TestCase&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mas o que vamos testar?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Como pretendo testar tanto a estrutura da minha base de dados, quanto o formulário e, de quebra, a validação do meu campo &lt;code&gt;geom&lt;/code&gt;, faço o &lt;code&gt;import&lt;/code&gt; do modelo &lt;code&gt;Fenomenos&lt;/code&gt; e do form &lt;code&gt;FenomenosForm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;⚠️ Essa não é uma boa prática. O ideal é criar uma pasta para os testes e separá-los em arquivos distintos. Um para cada elemento do sistema (model, form, view, etc).&lt;/p&gt;
&lt;p&gt;O primeiro teste será a carga de dados. Então, vou instanciar um objeto com o resultado da criação de um elemento do meu &lt;code&gt;model&lt;/code&gt; &lt;code&gt;Fenomeno&lt;/code&gt;. Faço isso no &lt;code&gt;setUp&lt;/code&gt;, para não ter que criá-lo sempre que for fazer um teste relacionado à carga de dados.&lt;/p&gt;
&lt;p&gt;O teste seguinte será relacionado ao formulário e por isso instancio um formulário com os dados carregados e testo a sua validez. Ao fazer isso o formulário passa pelo processo de limpeza, onde está a construção e validação do campo &lt;code&gt;geom&lt;/code&gt;. Se qualquer campo for preenchido com dados errados ou inadequados, o django retornará &lt;code&gt;False&lt;/code&gt; ao método &lt;code&gt;is_valid&lt;/code&gt;. Ou seja, se eu tiver construido o campo &lt;code&gt;geom&lt;/code&gt; de forma equivocada, passando mais ou menos parâmetros que o esperado o nosso teste irá avisar, evitando surpresas.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# tests.py
from django.test import TestCase
from geojson import Point

from map_proj.core.models import Fenomeno
from map_proj.core.forms import FenomenoForm


class ModelGeomTest(TestCase):
    def setUp(self):
        self.fenomeno = Fenomeno.objects.create(
            nome=&#39;Arvore&#39;,
            data=&#39;2020-11-06&#39;,
            hora=&#39;09:30:00&#39;
        )

    def test_create(self):
        self.assertTrue(Fenomeno.objects.exists())


class FenomenoFormTest(TestCase):
    def setUp(self):
        self.form = FenomenoForm({
            &#39;nome&#39;: &#39;Teste&#39;,
            &#39;data&#39;: &#39;2020-01-01&#39;,
            &#39;hora&#39;: &#39;09:12:12&#39;,
            &#39;longitude&#39;: -45,
            &#39;latitude&#39;: -22})
        self.validation = self.form.is_valid()

    def test_form_is_valid(self):
        &amp;quot;&amp;quot;&amp;quot;&amp;quot;form must be valid&amp;quot;&amp;quot;&amp;quot;
        self.assertTrue(self.validation)

    def test_geom_coordinates(self):
        &amp;quot;&amp;quot;&amp;quot;after validating, geom have same values of longitude and latitude&amp;quot;&amp;quot;&amp;quot;
        self.assertEqual(self.form.cleaned_data[&#39;geom&#39;], Point(
            (self.form.cleaned_data[&#39;longitude&#39;],
        self.form.cleaned_data[&#39;latitude&#39;])))

    def test_geom_is_valid(self):
        &amp;quot;&amp;quot;&amp;quot;geom must be valid&amp;quot;&amp;quot;&amp;quot;
        self.assertTrue(self.form.cleaned_data[&#39;geom&#39;].is_valid)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⚠️ Reparem que:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;No &lt;code&gt;test_create()&lt;/code&gt; eu testo se existem objetos inseridos no model &lt;code&gt;Fenomeno&lt;/code&gt;. Logo, testo se o dado criado no &lt;code&gt;setUp&lt;/code&gt; foi corretamente incorporado no banco de dados.&lt;/li&gt;
&lt;li&gt;Na classe &lt;code&gt;FenomenosFormTest&lt;/code&gt; eu crio uma instância do meu modelForm e realizo três testes:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_form_is_valid()&lt;/code&gt; estou testando se os dados carregados são condizentes com o informado no model e, pelo fato desse método usar o método &lt;code&gt;clean()&lt;/code&gt;, posso dizer que estou testando indiretamente a validez do campo &lt;code&gt;geom&lt;/code&gt;. Caso ele não fosse válido, o form também não seria válido.&lt;/li&gt;
&lt;li&gt;Em &lt;code&gt;test_geom_coordinates()&lt;/code&gt; testo se após a validação o campo geom foi criado como esperado (como uma instância de Point com os dalores de longitude e latitude).&lt;/li&gt;
&lt;li&gt;O teste &lt;code&gt;test_geom_is_valid()&lt;/code&gt; serve para garantir que a contrução do campo geom é valido. Ainda que ao testar se o formulário é valido eu estaria implicitamente testando a validez do campo geom, esse teste serve para garantir a criação válida do campo. Afinal, por algum motivo (como por exemplo, refatoração), pode ser que façamos alguma alteração no método &lt;code&gt;clean()&lt;/code&gt; que mantenha o formulário como válido mas deixe de garantir a validez do campo geom.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A diferença entre as classes de teste criadas está no fato de ao inserir os dados usando o método &lt;code&gt;create()&lt;/code&gt; - e aconteceria o mesmo se estivesse usando o &lt;code&gt;save()&lt;/code&gt; -, apenas será validado se o elemento a ser inserido é condizente com o tipo de coluna no banco de dados. Vale deixar claro: Dessa forma, eu não estou validando a consistência do campo &lt;code&gt;geom&lt;/code&gt;, já que o mesmo, caso seja informado, será salvo com sucesso sempre que represente um &lt;code&gt;JSON&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Esse fato é importante para reforçar o entendimento de que o &lt;code&gt;djgeojson&lt;/code&gt; implementa classes de alto nível a serem trabalhados em &lt;code&gt;views&lt;/code&gt; e &lt;code&gt;models&lt;/code&gt;. No banco, mesmo, temos um campo de &lt;code&gt;JSON&lt;/code&gt;.
Enquanto que, para poder validar a consistência do campo &lt;code&gt;geom&lt;/code&gt;, preciso passar os dados pelo formulário onde, no processo de limpeza do mesmo, o campo será criado e validado usando o módulo &lt;code&gt;geojson&lt;/code&gt;. Por isso a classe com os testes relacionados ao comportamento do formulário.&lt;/p&gt;
&lt;h3 id=&#34;registrando-modelo-no-admin&#34;&gt;Registrando modelo no admin&lt;/h3&gt;
&lt;p&gt;Para facilitar, vou usar o django-admin. Trata-se de uma aplicação já criada onde basta registrar os modelos e views que estamos trabalhando para termos uma interface &amp;ldquo;frontend&amp;rdquo; genérica.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#admin.py
from django.contrib import admin
from map_proj.core.models import Fenomeno
from map_proj.core.forms import FenomenoForm

class FenomenoAdmin(admin.ModelAdmin):
    model = Fenomeno
    form = FenomenoForm

admin.site.register(Fenomeno, FenomenoAdmin)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;to-be-continued&#34;&gt;To be continued&amp;hellip;&lt;/h3&gt;
&lt;p&gt;Até o momento já temos algo bastante interessante: um sistema de CRUD que nos permite adicionar, editar e remover dados geográficos. Talvez você esteja pensando consigo mesmo:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;OK. Mas o que foi feito até agora, poderia ter sido feito basicamente com uma base de dados que possuam as colunas latitude e longitude&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eu diria que sim, até certo ponto. Uma grande diferença, eu diria, da forma como foi implementada é o uso das ferramentas de validação dos dados com o módulo &lt;code&gt;geojson&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A ideia é, a seguir (e seja lá quando isso for), extender a funcionalidade do sistema ao implementar um webmap para visualizar os dados mapeados.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artigo publicado também no &lt;a href=&#34;https://www.linkedin.com/pulse/criando-um-sistema-para-gest%C3%A3o-de-dados-geogr%C3%A1ficos-e-felipe-/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;linkedin&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Para quem só sabe usar martelo, todo problema é um prego. Até rasters em formato netCDF.</title>
      <link>/post/netcdf/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/netcdf/</guid>
      <description>


&lt;p&gt;Nas últimas semanas estive trabalhando em um projeto com dados atmosféricos. Tem sido de grande aprendizado não apenas por ser uma temática nova, mas também pela demanda de processamento de dados.&lt;/p&gt;
&lt;p&gt;Os aprendizados relacionados ao processamento de dados (sua otimização, claro), serão abordados em artigos ainda em produção. Mas um ponto fundamental e que percebi ser ignorado pela maioria, e neste sentido me incluo, é a estrutura de dados dos arquivos raster em &lt;em&gt;netCDF.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Já vi, e já respodi a muitas pessoas perguntando como carregar dados &lt;em&gt;netCDF&lt;/em&gt; no R, com um simples “com o pacote &lt;code&gt;raster&lt;/code&gt;, ora bolas”. No pior das hipóteses, teremos apenas que instalar uma dependencia que é o pacote &lt;code&gt;ncdf4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pois é, os dados atmosféricos que tenho trabahado estão em formato &lt;em&gt;netCDF&lt;/em&gt;. E usar o pacote &lt;code&gt;raster&lt;/code&gt; para carregá-lo e manipulá-lo, me foi útil enquanto a análise era exploratória. Ao ver o volume de dados crescer de três dias para dois meses e, em seguida para dois anos de dados produzidos a cada três horas do dia, todos os dias, totalizando 731 arquivos, percebi que precisaria deixar de preguiça e entender esse tal de &lt;em&gt;netCDF&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Lendo sobre o pacote &lt;code&gt;ncdf4&lt;/code&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, o formato &lt;em&gt;netCDF&lt;/em&gt; é descrito da seguinte forma:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“binary data files that are portable across platforms and include metadata information in addition to the data sets.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Acho nesse fragmento já dá para entender a importância do formato, não?&lt;/p&gt;
&lt;p&gt;Vamos entender isso? Vejam a diferença:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(raster)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: sp&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(r.ppm25 &amp;lt;- stack(&amp;quot;./rasters/ppm25_2019-06-30.nc&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required namespace: ncdf4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterStack 
## dimensions : 59, 75, 4425, 6  (nrow, ncol, ncell, nlayers)
## resolution : 0.4, 0.4  (x, y)
## extent     : -74.19, -44.19, -18.24, 5.36  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
## names      : X2019.06.30.12.00.00, X2019.06.30.15.00.00, X2019.06.30.18.00.00, X2019.06.30.21.00.00, X2019.07.01.00.00.00, X2019.07.01.03.00.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aos que já trabalham com o pacote &lt;code&gt;raster&lt;/code&gt; e conhecem os dados raster, poderão ver que, sim, ainda que dependendo do &lt;code&gt;ncdf4&lt;/code&gt;, o &lt;code&gt;raster&lt;/code&gt; carrega os dados, aparentemente, sem grandes problemas. O mínimo esperado está aí. Um raster, com um &lt;code&gt;extent&lt;/code&gt;, linhas, colunas, células, layers…&lt;/p&gt;
&lt;p&gt;Mas, se os dados estão em &lt;em&gt;netCDF&lt;/em&gt;, e esse tipo de dados permite armazenar metadados também, cadê eles?&lt;/p&gt;
&lt;p&gt;Pois é. Ao ignorar isso, passava por cima desse detalhe como um marreteiro diante de um parafuso.&lt;/p&gt;
&lt;p&gt;Vamos abrir o arquivo com o &lt;code&gt;ncdf4&lt;/code&gt; para começar a identificar alguns pontos importantes, que, por sinal não ficam “apenas” no metadados:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ncdf4)
(nc.ppm25 &amp;lt;- nc_open(&amp;quot;./rasters/ppm25_2019-06-30.nc&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## File ./rasters/ppm25_2019-06-30.nc (NC_FORMAT_64BIT):
## 
##      1 variables (excluding dimension variables):
##         short pm2p5[longitude,latitude,time]   
##             scale_factor: 9.668789576322e-12
##             add_offset: 3.16807559257767e-07
##             _FillValue: -32767
##             missing_value: -32767
##             units: kg m**-3
##             long_name: Particulate matter d &amp;lt; 2.5 um
##             standard_name: mass_concentration_of_pm2p5_ambient_aerosol_particles_in_air
## 
##      3 dimensions:
##         longitude  Size:75
##             units: degrees_east
##             long_name: longitude
##         latitude  Size:59
##             units: degrees_north
##             long_name: latitude
##         time  Size:6   *** is unlimited ***
##             units: hours since 1900-01-01 00:00:00.0
##             long_name: time
##             calendar: gregorian
## 
##     2 global attributes:
##         Conventions: CF-1.6
##         history: 2021-03-17 20:27:56 GMT by grib_to_netcdf-2.20.0: grib_to_netcdf /data/scratch/20210317-2020/8e/_mars-webmars-public-svc-blue-001-6fe5cac1a363ec1525f54343b6cc9fd8-ZAB6WD.grib -o /data/scratch/20210317-2020/b1/_grib2netcdf-webmars-public-svc-blue-000-6fe5cac1a363ec1525f54343b6cc9fd8-VDR6DW.nc -utime&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Antes de comentar toda riqueza e detalhamento de informação que nos brinda o &lt;code&gt;ncdf4&lt;/code&gt;, percebam que o comando é &lt;code&gt;nc_open()&lt;/code&gt;. Não importa de o dado tem uma ou mais “bandas” ou “camadas”. Isso me chamou atenção pois, como acham que vou saber a quantidade de camadas do dados que vou abrir, se ainda não o conheço? Mas enfim. Vamos ao mais importante, os detalhes:&lt;/p&gt;
&lt;p&gt;Veja a estruturação. No arquivo em questão, eu tenho uma &lt;strong&gt;variável&lt;/strong&gt; apenas, que possui vários metadados, garantindo minimamente sua compreensão, como: &lt;em&gt;short_name&lt;/em&gt;, no caso “pm2p5”, &lt;em&gt;units&lt;/em&gt;, para descrever a unidade do dado, &lt;em&gt;long_name&lt;/em&gt; e &lt;em&gt;standart_name&lt;/em&gt;, além de vários outros.&lt;/p&gt;
&lt;p&gt;E vejam também que são identificadas três dimensões:
longitude, latitude e &lt;strong&gt;time&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;Eis que chegamos ao cubo de dados, não faz sentido?&lt;/p&gt;
&lt;p&gt;Eu tenho uma variável (ppm&amp;lt;2.5) medida para uma mesma área (cena) ao longo do tempo. O &lt;em&gt;netCDF&lt;/em&gt;, como está preparado e pensado para esse tipo de situação já entende os dados como informação de dadta e hora (!) e os organiza como uma dimensão do dado e não atributo. O &lt;code&gt;raster&lt;/code&gt;, por ter outros objetivos, carrega tudo como um &lt;em&gt;stack&lt;/em&gt; (empilhamento de camadas) e adiciona uma string “X” ao nome das camadas, já que as mesmas são numéricas e o pacote em questão restringe o prefixo das camadas a texto, não permitindo valores numéricos. Enfim, nos obriga a digitar mais algumas linhas de código para que o dado fique mais apresentável.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;imgs/cube1.png&#34; alt=&#34;Fonte da imagem: r-spatial.github.io&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Fonte da imagem: &lt;a href=&#34;http://r-spatial.github.io&#34;&gt;r-spatial.github.io&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Essa forma de estruturar os dados fará todo o sentido mais à frente quando formos falar um pouco mais do processamento desses dados.&lt;/p&gt;
&lt;p&gt;O pacote &lt;code&gt;ncdf4&lt;/code&gt; está desenvolvido para o que se convêm chamar de CRUD, na área de desenvolvimento de sistemas: &lt;em&gt;Create, Update and Delete&lt;/em&gt;. Ou, seja, a ideia é fornecer ferramentas para manipular e ter controle total dos dados, criando, abrindo, alterando dimensões ou atributos e por aí vai. Mas não para visualização nem para as análises. Essas, ficarão para os próximos artigos.&lt;/p&gt;
&lt;p&gt;Enquanto isso, fique à vontade em me contactar, dar uma alô lá &lt;a href=&#34;http://t.me/GeoCastBrasil&#34;&gt;no grupo do GeoCastBrasil&lt;/a&gt;, no Telegram ou no nosso &lt;a href=&#34;http://youtube.com/GeoCastBrasil&#34;&gt;canal do youtube&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Não pretendo explorar muitos detalhes, mas o nome do pacote (&lt;code&gt;ncdf4&lt;/code&gt;) faz referência à versão 4 de estratura em questão. Portanto, caso você esteja, por algum motivo, usando um arquivo &lt;em&gt;netCDF&lt;/em&gt; com versão anterior, o pacote &lt;code&gt;ncdf&lt;/code&gt; segue disponível, ainda que descontinuado.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>O Manifesto Nooscope</title>
      <link>/post/o-manifesto-nooscope/</link>
      <pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate>
      <guid>/post/o-manifesto-nooscope/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Cientista de dados geográficos - Como cheguei até aqui?!</title>
      <link>/post/cientista-dados-geograficos-como-cheguei-aqui/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/post/cientista-dados-geograficos-como-cheguei-aqui/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
